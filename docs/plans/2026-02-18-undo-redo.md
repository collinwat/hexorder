# Undo/Redo System Implementation Plan (Scope 1+2)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan
> task-by-task.

**Goal:** Build the undo/redo contract (UndoableCommand trait, UndoStack resource), plugin
infrastructure (shortcuts, exclusive system), and first concrete command type (SetPropertyCommand)
to exercise the full undo/redo loop end-to-end.

**Architecture:** Command pattern with trait objects. Plugins create command structs implementing
`UndoableCommand`, record them on `UndoStack` after performing the mutation. Undo/redo execution
happens in an exclusive system with `&mut World` access. Shortcuts (Cmd+Z / Cmd+Shift+Z) set flags
on the stack; the exclusive system processes them.

**Tech Stack:** Bevy 0.18, Rust edition 2024. Observer events for shortcut dispatch. Exclusive
system for undo/redo world mutations. Contract types in `src/contracts/undo_redo.rs`.

---

## Design Decisions

**Why trait objects, not enums?** The pitch requires a `Command trait` in contracts so plugins can
implement their own undoable actions. Trait objects (`Box<dyn UndoableCommand>`) allow any plugin to
define commands without modifying the contract.

**Why `record()` not `push()`?** Forward mutations happen inline (no one-frame delay). After
mutating, plugins call `undo_stack.record(cmd)` to record the already-executed command. Only
undo/redo goes through the exclusive system with `&mut World`. This avoids egui widget flicker and
keeps the forward path unchanged.

**Why exclusive system?** `UndoableCommand::undo()` and `execute()` need `&mut World` to modify
arbitrary components/resources. Only exclusive systems provide that in Bevy.

---

### Task 1: Contract spec document

**Files:**

- Create: `docs/contracts/undo-redo.md`

**Step 1: Write the contract spec**

```markdown
# Contract: Undo/Redo

## Owner

`undo_redo` plugin

## Summary

Cross-cutting undo/redo infrastructure. Defines the command trait that plugins implement for
reversible actions, and the stack resource that tracks history.

## Types

### UndoableCommand (trait)

Trait for reversible commands. Implementors must be `Send + Sync + Debug`.

- `fn execute(&mut self, world: &mut World)` — apply this command's action
- `fn undo(&mut self, world: &mut World)` — reverse this command's action
- `fn description(&self) -> String` — human-readable label (e.g., "Set Attack to 5")

### UndoStack (Resource)

Manages undo/redo history.

- `undo_stack: Vec<Box<dyn UndoableCommand>>` — commands that can be undone
- `redo_stack: Vec<Box<dyn UndoableCommand>>` — commands that can be redone
- `max_depth: usize` — maximum stack size (default: 100)
- `pending_undo: bool` — flag set by observer, consumed by exclusive system
- `pending_redo: bool` — flag set by observer, consumed by exclusive system

Methods:

- `record(cmd)` — push an already-executed command onto undo stack, clear redo stack
- `request_undo()` — set pending_undo flag
- `request_redo()` — set pending_redo flag
- `can_undo() -> bool`
- `can_redo() -> bool`
- `undo_description() -> Option<String>`
- `redo_description() -> Option<String>`
- `clear()` — reset both stacks (e.g., on project load)

### SetPropertyCommand (struct)

Built-in command for property value changes.

- `entity: Entity`
- `property_id: TypeId`
- `old_value: PropertyValue`
- `new_value: PropertyValue`
- `label: String`

## Consumers

- `editor_ui` — reads `can_undo/can_redo` and descriptions for menu labels; pushes
  `SetPropertyCommand` for inspector edits
- `cell` — pushes commands for terrain painting (future Scope 3)
- `unit` — pushes commands for unit placement/deletion (future Scope 4)
- `persistence` — calls `clear()` on project load

## Events

None. Undo/redo is triggered via `CommandExecutedEvent` from the shortcuts contract (`edit.undo`,
`edit.redo`). The UndoStack uses internal flags, not events.
```

**Step 2: Commit**

```bash
git add docs/contracts/undo-redo.md
git commit -m "docs(contracts): add undo-redo contract spec"
```

---

### Task 2: Contract code — UndoableCommand trait and UndoStack resource

**Files:**

- Create: `src/contracts/undo_redo.rs`
- Modify: `src/contracts/mod.rs`

**Step 1: Write tests for UndoStack**

Add a `#[cfg(test)] mod tests` block at the bottom of `src/contracts/undo_redo.rs` with these tests:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    /// A trivial command that increments/decrements an i32 Resource for testing.
    #[derive(Debug)]
    struct IncrementCommand {
        amount: i32,
    }

    #[derive(Resource, Debug, Default)]
    struct Counter(i32);

    impl UndoableCommand for IncrementCommand {
        fn execute(&mut self, world: &mut World) {
            world.resource_mut::<Counter>().0 += self.amount;
        }
        fn undo(&mut self, world: &mut World) {
            world.resource_mut::<Counter>().0 -= self.amount;
        }
        fn description(&self) -> String {
            format!("Increment by {}", self.amount)
        }
    }

    #[test]
    fn record_pushes_to_undo_stack() {
        let mut stack = UndoStack::new(100);
        stack.record(Box::new(IncrementCommand { amount: 1 }));
        assert!(stack.can_undo());
        assert!(!stack.can_redo());
    }

    #[test]
    fn record_clears_redo_stack() {
        let mut stack = UndoStack::new(100);
        stack.record(Box::new(IncrementCommand { amount: 1 }));
        // Simulate an undo by moving to redo manually
        let cmd = stack.pop_undo().expect("should have command");
        stack.push_redo(cmd);
        assert!(stack.can_redo());
        // Recording a new command should clear redo
        stack.record(Box::new(IncrementCommand { amount: 2 }));
        assert!(!stack.can_redo());
    }

    #[test]
    fn max_depth_enforced() {
        let mut stack = UndoStack::new(3);
        for i in 0..5 {
            stack.record(Box::new(IncrementCommand { amount: i }));
        }
        assert_eq!(stack.undo_len(), 3);
    }

    #[test]
    fn undo_description_returns_top_command() {
        let mut stack = UndoStack::new(100);
        stack.record(Box::new(IncrementCommand { amount: 42 }));
        assert_eq!(
            stack.undo_description().as_deref(),
            Some("Increment by 42")
        );
    }

    #[test]
    fn empty_stack_returns_none() {
        let stack = UndoStack::new(100);
        assert!(!stack.can_undo());
        assert!(!stack.can_redo());
        assert!(stack.undo_description().is_none());
        assert!(stack.redo_description().is_none());
    }

    #[test]
    fn clear_resets_both_stacks() {
        let mut stack = UndoStack::new(100);
        stack.record(Box::new(IncrementCommand { amount: 1 }));
        let cmd = stack.pop_undo().expect("should have command");
        stack.push_redo(cmd);
        stack.record(Box::new(IncrementCommand { amount: 2 }));
        stack.clear();
        assert!(!stack.can_undo());
        assert!(!stack.can_redo());
    }
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test --lib contracts::undo_redo -- --nocapture
```

Expected: compilation error (module doesn't exist yet).

**Step 3: Write the contract implementation**

```rust
//! Shared Undo/Redo types. See `docs/contracts/undo-redo.md`.
//!
//! Defines the command pattern trait for reversible actions and the
//! undo/redo stack resource. Plugins implement `UndoableCommand` for
//! their domain-specific mutations.

use std::fmt;

use bevy::prelude::*;

use super::game_system::{PropertyValue, TypeId};

// ---------------------------------------------------------------------------
// Command Trait
// ---------------------------------------------------------------------------

/// Trait for reversible editor commands. Every user action that modifies
/// state implements this trait to support undo/redo.
///
/// Implementors must capture enough state to fully reverse the action.
/// Commands are stored as trait objects on the `UndoStack`.
pub trait UndoableCommand: Send + Sync + fmt::Debug {
    /// Apply this command's action to the world.
    fn execute(&mut self, world: &mut World);

    /// Reverse this command's action.
    fn undo(&mut self, world: &mut World);

    /// Human-readable description for UI display
    /// (e.g., "Set Attack to 5", "Paint hex (0, 1) to Plains").
    fn description(&self) -> String;
}

// ---------------------------------------------------------------------------
// Undo Stack Resource
// ---------------------------------------------------------------------------

/// Resource managing the undo and redo command history.
///
/// Forward mutations happen inline — plugins mutate state directly and
/// then call `record()` to push the command for undo tracking. Only
/// undo/redo execution goes through the exclusive system.
#[derive(Resource)]
pub struct UndoStack {
    undo_stack: Vec<Box<dyn UndoableCommand>>,
    redo_stack: Vec<Box<dyn UndoableCommand>>,
    max_depth: usize,
    /// Set by observer, consumed by exclusive system.
    pub(crate) pending_undo: bool,
    /// Set by observer, consumed by exclusive system.
    pub(crate) pending_redo: bool,
}

impl fmt::Debug for UndoStack {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("UndoStack")
            .field("undo_len", &self.undo_stack.len())
            .field("redo_len", &self.redo_stack.len())
            .field("max_depth", &self.max_depth)
            .finish()
    }
}

impl UndoStack {
    /// Create a new stack with the given maximum depth.
    #[must_use]
    pub fn new(max_depth: usize) -> Self {
        Self {
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            max_depth,
            pending_undo: false,
            pending_redo: false,
        }
    }

    /// Record an already-executed command. Pushes it onto the undo stack
    /// and clears the redo stack (standard undo behavior).
    pub fn record(&mut self, command: Box<dyn UndoableCommand>) {
        self.redo_stack.clear();
        self.undo_stack.push(command);
        if self.undo_stack.len() > self.max_depth {
            self.undo_stack.remove(0);
        }
    }

    /// Request an undo operation. Processed by the exclusive system.
    pub fn request_undo(&mut self) {
        self.pending_undo = true;
    }

    /// Request a redo operation. Processed by the exclusive system.
    pub fn request_redo(&mut self) {
        self.pending_redo = true;
    }

    /// Returns true if there are commands to undo.
    #[must_use]
    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    /// Returns true if there are commands to redo.
    #[must_use]
    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }

    /// Description of the command that would be undone, if any.
    #[must_use]
    pub fn undo_description(&self) -> Option<String> {
        self.undo_stack.last().map(|cmd| cmd.description())
    }

    /// Description of the command that would be redone, if any.
    #[must_use]
    pub fn redo_description(&self) -> Option<String> {
        self.redo_stack.last().map(|cmd| cmd.description())
    }

    /// Number of commands on the undo stack.
    #[must_use]
    pub fn undo_len(&self) -> usize {
        self.undo_stack.len()
    }

    /// Number of commands on the redo stack.
    #[must_use]
    pub fn redo_len(&self) -> usize {
        self.redo_stack.len()
    }

    /// Pop the top command from the undo stack.
    pub(crate) fn pop_undo(&mut self) -> Option<Box<dyn UndoableCommand>> {
        self.undo_stack.pop()
    }

    /// Push a command onto the redo stack.
    pub(crate) fn push_redo(&mut self, command: Box<dyn UndoableCommand>) {
        self.redo_stack.push(command);
    }

    /// Pop the top command from the redo stack.
    pub(crate) fn pop_redo(&mut self) -> Option<Box<dyn UndoableCommand>> {
        self.redo_stack.pop()
    }

    /// Push a command onto the undo stack (used after redo).
    pub(crate) fn push_undo(&mut self, command: Box<dyn UndoableCommand>) {
        self.undo_stack.push(command);
        if self.undo_stack.len() > self.max_depth {
            self.undo_stack.remove(0);
        }
    }

    /// Clear both stacks. Call on project load to reset history.
    pub fn clear(&mut self) {
        self.undo_stack.clear();
        self.redo_stack.clear();
    }
}

impl Default for UndoStack {
    fn default() -> Self {
        Self::new(100)
    }
}

// ---------------------------------------------------------------------------
// Built-in Command: SetProperty
// ---------------------------------------------------------------------------

/// Command that changes a single property value on an entity.
/// Captures old and new values for undo/redo.
#[derive(Debug)]
pub struct SetPropertyCommand {
    /// The entity whose property changed.
    pub entity: Entity,
    /// The property definition ID.
    pub property_id: TypeId,
    /// Value before the change.
    pub old_value: PropertyValue,
    /// Value after the change.
    pub new_value: PropertyValue,
    /// Human-readable label (e.g., "Set Attack to 5").
    pub label: String,
}

impl UndoableCommand for SetPropertyCommand {
    fn execute(&mut self, world: &mut World) {
        if let Some(mut data) = world.get_mut::<super::game_system::EntityData>(self.entity) {
            data.properties
                .insert(self.property_id, self.new_value.clone());
        }
    }

    fn undo(&mut self, world: &mut World) {
        if let Some(mut data) = world.get_mut::<super::game_system::EntityData>(self.entity) {
            data.properties
                .insert(self.property_id, self.old_value.clone());
        }
    }

    fn description(&self) -> String {
        self.label.clone()
    }
}
```

**Step 4: Register in mod.rs**

Add to `src/contracts/mod.rs`:

```rust
#[allow(dead_code)]
pub mod undo_redo;
```

**Step 5: Run tests to verify they pass**

```bash
cargo test --lib contracts::undo_redo -- --nocapture
```

Expected: all 6 tests pass.

**Step 6: Commit**

```bash
git add src/contracts/undo_redo.rs src/contracts/mod.rs docs/contracts/undo-redo.md
git commit -m "feat(contracts): add undo-redo contract with UndoableCommand trait and UndoStack"
```

---

### Task 3: Plugin skeleton — UndoRedoPlugin with shortcuts and exclusive system

**Files:**

- Create: `src/undo_redo/mod.rs`
- Create: `src/undo_redo/systems.rs`
- Create: `src/undo_redo/tests.rs`
- Modify: `src/main.rs`
- Modify: `docs/architecture.md` (plugin load order + dependency graph)

**Step 1: Write tests for the plugin systems**

In `src/undo_redo/tests.rs`:

```rust
use bevy::prelude::*;

use crate::contracts::game_system::{EntityData, PropertyValue, TypeId};
use crate::contracts::shortcuts::{CommandExecutedEvent, CommandId};
use crate::contracts::undo_redo::{SetPropertyCommand, UndoStack};

/// Build a minimal app with the UndoRedoPlugin for testing.
fn test_app() -> App {
    let mut app = App::new();
    app.add_plugins(MinimalPlugins);
    app.add_plugins(super::UndoRedoPlugin);
    app
}

#[test]
fn undo_redo_plugin_inserts_stack_resource() {
    let app = test_app();
    assert!(app.world().get_resource::<UndoStack>().is_some());
}

#[test]
fn process_undo_reverses_command() {
    let mut app = test_app();
    app.update();

    let prop_id = TypeId::new();
    let entity = app
        .world_mut()
        .spawn(EntityData {
            entity_type_id: TypeId::new(),
            properties: [(prop_id, PropertyValue::Int(10))].into(),
        })
        .id();

    // Record a property change (forward mutation already applied).
    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(20),
            label: "Set to 20".to_string(),
        },
    ));

    // Request undo.
    app.world_mut().resource_mut::<UndoStack>().request_undo();
    app.update(); // Exclusive system processes the undo.

    let data = app
        .world()
        .entity(entity)
        .get::<EntityData>()
        .expect("entity should have EntityData");
    assert_eq!(
        data.properties.get(&prop_id),
        Some(&PropertyValue::Int(10)),
        "Property should be reverted to old value"
    );
}

#[test]
fn process_redo_reapplies_command() {
    let mut app = test_app();
    app.update();

    let prop_id = TypeId::new();
    let entity = app
        .world_mut()
        .spawn(EntityData {
            entity_type_id: TypeId::new(),
            properties: [(prop_id, PropertyValue::Int(10))].into(),
        })
        .id();

    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(20),
            label: "Set to 20".to_string(),
        },
    ));

    // Undo, then redo.
    app.world_mut().resource_mut::<UndoStack>().request_undo();
    app.update();
    app.world_mut().resource_mut::<UndoStack>().request_redo();
    app.update();

    let data = app
        .world()
        .entity(entity)
        .get::<EntityData>()
        .expect("entity should have EntityData");
    assert_eq!(
        data.properties.get(&prop_id),
        Some(&PropertyValue::Int(20)),
        "Property should be re-applied to new value"
    );
}

#[test]
fn undo_via_shortcut_command() {
    let mut app = test_app();
    app.update();

    let prop_id = TypeId::new();
    let entity = app
        .world_mut()
        .spawn(EntityData {
            entity_type_id: TypeId::new(),
            properties: [(prop_id, PropertyValue::Int(10))].into(),
        })
        .id();

    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(20),
            label: "Set to 20".to_string(),
        },
    ));

    // Fire edit.undo via CommandExecutedEvent (simulating Cmd+Z).
    app.world_mut().trigger(CommandExecutedEvent {
        command_id: CommandId("edit.undo"),
    });
    app.update();

    let data = app
        .world()
        .entity(entity)
        .get::<EntityData>()
        .expect("entity should have EntityData");
    assert_eq!(
        data.properties.get(&prop_id),
        Some(&PropertyValue::Int(10)),
        "Undo via shortcut should revert property"
    );
}

#[test]
fn redo_via_shortcut_command() {
    let mut app = test_app();
    app.update();

    let prop_id = TypeId::new();
    let entity = app
        .world_mut()
        .spawn(EntityData {
            entity_type_id: TypeId::new(),
            properties: [(prop_id, PropertyValue::Int(10))].into(),
        })
        .id();

    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(20),
            label: "Set to 20".to_string(),
        },
    ));

    app.world_mut().trigger(CommandExecutedEvent {
        command_id: CommandId("edit.undo"),
    });
    app.update();

    app.world_mut().trigger(CommandExecutedEvent {
        command_id: CommandId("edit.redo"),
    });
    app.update();

    let data = app
        .world()
        .entity(entity)
        .get::<EntityData>()
        .expect("entity should have EntityData");
    assert_eq!(
        data.properties.get(&prop_id),
        Some(&PropertyValue::Int(20)),
        "Redo via shortcut should re-apply property"
    );
}

#[test]
fn new_record_after_undo_clears_redo() {
    let mut app = test_app();
    app.update();

    let prop_id = TypeId::new();
    let entity = app
        .world_mut()
        .spawn(EntityData {
            entity_type_id: TypeId::new(),
            properties: [(prop_id, PropertyValue::Int(10))].into(),
        })
        .id();

    // Record action 1.
    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(20),
            label: "Set to 20".to_string(),
        },
    ));

    // Undo action 1.
    app.world_mut().resource_mut::<UndoStack>().request_undo();
    app.update();

    // Record action 2 (should clear redo).
    app.world_mut().resource_mut::<UndoStack>().record(Box::new(
        SetPropertyCommand {
            entity,
            property_id: prop_id,
            old_value: PropertyValue::Int(10),
            new_value: PropertyValue::Int(30),
            label: "Set to 30".to_string(),
        },
    ));

    assert!(
        !app.world().resource::<UndoStack>().can_redo(),
        "Redo stack should be cleared after new record"
    );
}
```

**Step 2: Run tests to verify they fail**

```bash
cargo test --lib undo_redo -- --nocapture
```

Expected: compilation error (module doesn't exist yet).

**Step 3: Write the plugin systems**

In `src/undo_redo/systems.rs`:

```rust
//! Systems for the undo_redo plugin.

use bevy::prelude::*;

use crate::contracts::shortcuts::CommandExecutedEvent;
use crate::contracts::undo_redo::UndoStack;

/// Observer: handles edit.undo and edit.redo commands from the shortcut registry.
pub fn handle_undo_redo_command(
    trigger: On<CommandExecutedEvent>,
    mut stack: ResMut<UndoStack>,
) {
    match trigger.event().command_id.0 {
        "edit.undo" => stack.request_undo(),
        "edit.redo" => stack.request_redo(),
        _ => {}
    }
}

/// Exclusive system: processes pending undo/redo operations.
/// Runs every frame. If no operations are pending, returns immediately.
pub fn process_undo_redo(world: &mut World) {
    let (do_undo, do_redo) = {
        let stack = world.resource::<UndoStack>();
        (stack.pending_undo, stack.pending_redo)
    };

    if do_undo {
        world.resource_mut::<UndoStack>().pending_undo = false;
        let cmd = world.resource_mut::<UndoStack>().pop_undo();
        if let Some(mut cmd) = cmd {
            cmd.undo(world);
            world.resource_mut::<UndoStack>().push_redo(cmd);
        }
    }

    if do_redo {
        world.resource_mut::<UndoStack>().pending_redo = false;
        let cmd = world.resource_mut::<UndoStack>().pop_redo();
        if let Some(mut cmd) = cmd {
            cmd.execute(world);
            world.resource_mut::<UndoStack>().push_undo(cmd);
        }
    }
}
```

**Step 4: Write the plugin module**

In `src/undo_redo/mod.rs`:

```rust
//! Undo/Redo plugin.
//!
//! Provides cross-cutting undo/redo infrastructure using the command pattern.
//! Registers Cmd+Z / Cmd+Shift+Z shortcuts and processes undo/redo operations
//! via an exclusive system with `&mut World` access.

use bevy::prelude::*;

use crate::contracts::shortcuts::{
    CommandCategory, CommandEntry, CommandId, KeyBinding, Modifiers, ShortcutRegistry,
};
use crate::contracts::undo_redo::UndoStack;

mod systems;

#[cfg(test)]
mod tests;

/// Plugin that manages undo/redo infrastructure.
#[derive(Debug)]
pub struct UndoRedoPlugin;

impl Plugin for UndoRedoPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<UndoStack>()
            .add_systems(Update, systems::process_undo_redo)
            .add_observer(systems::handle_undo_redo_command);

        register_shortcuts(
            app.world_mut()
                .resource_mut::<ShortcutRegistry>()
                .into_inner(),
        );
    }
}

fn register_shortcuts(registry: &mut ShortcutRegistry) {
    use bevy::input::keyboard::KeyCode;

    registry.register(CommandEntry {
        id: CommandId("edit.undo"),
        name: "Undo".to_string(),
        description: "Undo the last action".to_string(),
        bindings: vec![KeyBinding::new(KeyCode::KeyZ, Modifiers::CMD)],
        category: CommandCategory::Edit,
        continuous: false,
    });

    registry.register(CommandEntry {
        id: CommandId("edit.redo"),
        name: "Redo".to_string(),
        description: "Redo the last undone action".to_string(),
        bindings: vec![KeyBinding::new(KeyCode::KeyZ, Modifiers::CMD_SHIFT)],
        category: CommandCategory::Edit,
        continuous: false,
    });
}
```

**Step 5: Register plugin in main.rs**

Add `mod undo_redo;` to the module declarations and `.add_plugins(undo_redo::UndoRedoPlugin)` to the
app builder — after `ShortcutsPlugin` and before `EditorUiPlugin`. The plugin depends on
`ShortcutRegistry` (from ShortcutsPlugin).

Suggested position in load order: after `PersistencePlugin`, before `EditorUiPlugin`:

```rust
.add_plugins(persistence::PersistencePlugin)
.add_plugins(undo_redo::UndoRedoPlugin)      // NEW
.add_plugins(editor_ui::EditorUiPlugin)
```

**Step 6: Update architecture.md**

Add `UndoRedoPlugin` to the plugin load order (position 12, before EditorUiPlugin which becomes 13).
Add to the dependency graph:

```
undo_redo (contract)   ──→ editor_ui
shortcuts (contract)   ──→ undo_redo
game_system (contract) ──→ undo_redo

undo_redo: depends on shortcuts + game_system contracts
```

**Step 7: Run tests to verify they pass**

```bash
cargo test --lib undo_redo -- --nocapture
```

Expected: all 6 tests pass.

**Step 8: Run full test suite**

```bash
cargo test
```

Expected: all tests pass (including architecture tests).

**Step 9: Run clippy**

```bash
cargo clippy --all-targets
```

Expected: zero warnings.

**Step 10: Commit**

```bash
git add src/undo_redo/ src/main.rs docs/architecture.md
git commit -m "feat(undo_redo): add UndoRedoPlugin with shortcuts and exclusive system"
```

---

### Task 4: SetPropertyCommand integration test

**Files:**

- Modify: `src/undo_redo/tests.rs` (tests are already written in Task 3)

This task verifies the tests written in Task 3 actually exercise the SetPropertyCommand through the
full Bevy app lifecycle. The tests are already defined — this task is about running them and
confirming the vertical slice works.

**Step 1: Run all undo_redo tests**

```bash
cargo test --lib undo_redo -- --nocapture
```

Expected: all tests pass.

**Step 2: Run boundary check**

```bash
mise check:boundary
```

Expected: no cross-plugin import violations.

**Step 3: Run unwrap check**

```bash
mise check:unwrap
```

Expected: no unwrap in production code.

**Step 4: Run full audit**

```bash
mise check
```

Expected: all checks pass.

---

### Task 5: Update plugin spec and log

**Files:**

- Modify: `docs/plugins/undo_redo/spec.md`
- Modify: `docs/plugins/undo_redo/log.md`

**Step 1: Update spec success criteria**

Mark completed criteria:

- [x] SC-1: UndoableCommand trait defined in contracts
- [x] SC-2: UndoStack resource with push, undo, redo and configurable depth
- [x] SC-3: Property changes are undoable (unit-tested)

**Step 2: Update log**

Add decision log entries for:

- Architecture: record-then-undo pattern (not push-then-execute)
- Exclusive system for World access
- Test results from Task 4

Update status from `speccing` to `in-progress`.

**Step 3: Commit**

```bash
git add docs/plugins/undo_redo/spec.md docs/plugins/undo_redo/log.md
git commit -m "docs(undo_redo): update spec and log after Scope 1+2"
```

---

### Task 6: Post progress update

Post a comment on pitch #84:

```bash
gh issue comment 84 --body "Scope 1+2 complete (commit <SHA>): Contract, stack, plugin,
SetPropertyCommand, and 6 tests passing. Full undo/redo loop verified end-to-end via exclusive
system. Architecture: record-after-mutation pattern avoids one-frame delay. Cmd+Z / Cmd+Shift+Z
wired through shortcuts contract."
```
