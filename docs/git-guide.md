# Hexorder — Git Guide

## Strategy

Hexorder uses a **trunk-based development model with worktrees**. The `main` branch is the mainline
— it must always compile, pass tests, and represent a releasable state. Feature work happens on
short-lived branches via git worktrees, merged back to `main` when complete.

Commits are frequent and small. Merges to mainline are deliberate and accompanied by a version bump
and changelog entry.

---

## Setup

Project tooling is managed by [mise](https://mise.jdx.dev/). Git hooks are managed by
[lefthook](https://github.com/evilmartians/lefthook). Changelogs are generated by
[git-cliff](https://git-cliff.org/).

### First-time setup

```bash
mise install        # installs lefthook, git-lfs, and any other project tools
git lfs install     # configures git-lfs for this user (once per machine)
lefthook install    # installs git hooks into .git/hooks/
```

### What the hooks enforce

| Hook         | What it checks                                                                                            |
| ------------ | --------------------------------------------------------------------------------------------------------- |
| `commit-msg` | Message matches `<type>(<scope>): <summary>` with valid types and scopes. Subject line max 72 characters. |
| `pre-commit` | No secrets staged (`.env`, credentials, keys). `cargo build` succeeds.                                    |

These hooks are the automated enforcement of the Pre-Commit Checklist. If a hook rejects your
commit, fix the issue — do not bypass with `--no-verify`.

### Git LFS

Binary assets (images, fonts, audio, 3D models) are tracked by Git LFS to prevent repo bloat.
Tracked patterns are defined in `.gitattributes` at the project root.

When adding a **new binary file type** to the project, add a corresponding LFS tracking rule to
`.gitattributes` before committing the files.

### Configuration

- `mise.toml` — declares project tools (lefthook, git-lfs, git-cliff)
- `lefthook.yml` — defines hook commands and validation rules
- `cliff.toml` — defines changelog generation template and commit parsers
- `.gitattributes` — defines Git LFS tracking patterns for binary assets

When adding a new feature scope (e.g., a new plugin), update the scope regex in `lefthook.yml`'s
`commit-msg` hook to include it.

---

## Branching

### Mainline: `main`

- Always builds (`cargo build` clean)
- Always passes tests (`cargo test`) and lint (`cargo clippy -- -D warnings`)
- Every merge to `main` is tagged with a release version
- Direct commits to `main` are limited to project-level config and documentation (e.g., CLAUDE.md,
  docs/, .specs/ process files)

### Feature branches

- One branch per feature or milestone task
- Use **git worktrees** so each feature gets its own working directory, allowing parallel
  development without stashing or switching
- Keep branches short-lived — merge when the feature passes its spec criteria and tests
- Rebase onto `main` before merging to keep history linear

### Branch naming

Branch names **must** follow this pattern:

```
<milestone>/<feature>
```

- `<milestone>` is the lowercase milestone identifier: `m1`, `m2`, `m3`, etc.
- `<feature>` is the feature name as it appears in `.specs/coordination.md`, using hyphens for
  multi-word names

**Valid**: `m3/unit`, `m3/editor-ui`, `m4/movement-rules` **Invalid**: `feature/unit`,
`unit-placement`, `m3_unit`, `m3/Unit`

For non-feature work (docs, process, tooling), use:

```
<milestone>/chore-<description>
```

**Valid**: `m3/chore-git-guide`, `m4/chore-ci-setup`

---

## Feature Branch Setup Checklist

Run these steps in order when starting work on a new feature. No steps are optional.

1. **Branch name.** Determine the branch name: `<milestone>/<feature>` (e.g., `m4/movement-rules`).
   Verify it follows the naming rules above.
2. **Create branch and worktree.**
   ```bash
   git branch m4/movement-rules
   git worktree add ../hexorder-m4-movement-rules m4/movement-rules
   cd ../hexorder-m4-movement-rules
   ```
3. **Install hooks in worktree.** Run `lefthook install` in the new worktree directory. Worktrees
   have their own git hooks and need lefthook installed separately.
4. **Set pre-release version.** Edit `Cargo.toml` and append a pre-release suffix to the version:
   ```toml
   version = "0.4.0-movement-rules"
   ```
   The suffix is the `<feature>` portion of the branch name. This identifies builds from this
   branch. The suffix is stripped at merge time when the final version is set.
5. **Spec scaffolding.** Verify the feature has spec and log files. If they don't exist, create them
   from the templates:
   ```
   .specs/features/<feature>/spec.md   ← copy from .specs/features/_template_spec.md
   .specs/features/<feature>/log.md    ← copy from .specs/features/_template_log.md
   ```
   If the files already exist, read them to understand prior decisions.
6. **Contract check.** Read `.specs/contracts/` for any shared types the feature depends on or
   introduces. If new contracts are needed, follow the Shared Contracts Protocol in CLAUDE.md.
7. **Claim ownership.** Update `.specs/coordination.md` → Active Features table: set Owner to your
   session identifier and Status to `in-progress`.
8. **Initial commit.** Stage the `Cargo.toml` version change, any new spec/log files, and the
   coordination.md update. Commit:

   ```
   chore(<feature>): set up feature branch

   Create worktree, set pre-release version, scaffold specs.
   Part of <milestone>.
   ```

After this checklist, proceed to the Development Workflow in CLAUDE.md.

---

## Feature Branch Teardown Checklist

Run these steps after a feature branch has been merged to `main` and the merge tag is verified.

1. **Verify merge.** Confirm the merge commit and tag exist on `main`:
   ```bash
   git log --oneline -5 main
   git tag -l 'v0.*'
   ```
2. **Remove worktree.**
   ```bash
   git worktree remove ../hexorder-<milestone>-<feature>
   ```
3. **Delete branch.**
   ```bash
   git branch -d <milestone>/<feature>
   ```
4. **Update ownership.** In `.specs/coordination.md` → Active Features table, set Status to
   `complete` and clear Owner.
5. **Release merge lock.** If not already done in the Pre-Merge Checklist, confirm your Merge Lock
   row status is `done`.
6. **Verify clean state.** Run `git worktree list` and confirm only the main worktree remains (plus
   any other active feature worktrees).

---

## Commits

### Commit early and often

- Commit whenever you reach a coherent working state — a system compiles, a test passes, a contract
  is defined
- Small, frequent commits are preferred over large, infrequent ones
- **Every commit must compile.** `cargo build` must succeed before committing. This is enforced by
  the `pre-commit` hook and keeps history bisect-friendly — `git bisect` can binary-search any
  regression across the commit history
- Incomplete work is fine on feature branches as long as it compiles; the merge to `main` is what
  matters for test quality
- Specs, contracts, and code for the same change travel together in the same commit

### Checkpoint commits

Before attempting a risky change (large refactor, contract modification, deleting significant code),
commit the current known-good state as a checkpoint:

```
chore(<feature>): checkpoint before <description>
```

Examples:

```
chore(unit): checkpoint before movement system refactor
chore(contracts): checkpoint before adding unit stacking types
```

This gives a clean rollback point. If the risky change fails or goes wrong:

```bash
git reset --hard HEAD~<n>   # roll back to the checkpoint
```

Checkpoint commits are normal commits — they travel with the branch and get merged. They're cheap
insurance against lost work, especially for agents that can't interactively undo edits.

### Commit message format

Follow **conventional commit** practices. Every commit message **must** match this structure:

```
<type>(<scope>): <summary>

<optional body>
```

**Types** — use exactly one of:

| Type       | When to use                                                   |
| ---------- | ------------------------------------------------------------- |
| `feat`     | New functionality (system, component, plugin, UI element)     |
| `fix`      | Bug fix                                                       |
| `refactor` | Code restructuring with no behavior change                    |
| `test`     | Adding or updating tests only                                 |
| `docs`     | Documentation, specs, logs, guides                            |
| `chore`    | Build config, version bumps, tooling, cleanup                 |
| `style`    | Formatting, whitespace, brand/theme changes (no logic change) |

**Scope** — use exactly one of:

| Scope        | When to use                                                                                     |
| ------------ | ----------------------------------------------------------------------------------------------- |
| Feature name | Work within a single feature (`unit`, `cell`, `hex_grid`, `camera`, `game_system`, `editor_ui`) |
| `contracts`  | Shared type definitions in `src/contracts/` or `.specs/contracts/`                              |
| `project`    | Cross-cutting changes (CLAUDE.md, coordination, roadmap, git guide, build config)               |

**Subject line rules**:

- Imperative mood ("add", not "added" or "adds")
- Lowercase (no capital first letter)
- No trailing period
- Maximum 72 characters total (including type and scope)

**Body rules** (when present):

- Separated from subject by one blank line
- Wrap at 72 characters
- Explain _why_, not _what_ — the diff shows what changed
- Reference the milestone when relevant: "Part of M3"

**Examples**:

```
feat(unit): add unit placement and movement systems

Implements UnitPlugin with spawn, move, delete, and visual sync systems.
Adds 9 unit tests and 4 integration tests. Part of M3.
```

```
docs(contracts): add unit type contract spec

Defines UnitType, UnitData, UnitInstance, and UnitPlacedEvent shared
types for M3. Matches src/contracts/game_system.rs additions.
```

```
fix(editor_ui): prevent panel click from painting cells

Guard cell painting systems with egui_wants_any_pointer_input check.
```

```
chore(project): bump version to 0.3.0
```

---

## Pre-Commit Checklist

**Every commit** on a feature branch must pass this checklist. Steps 1-3 are **enforced
automatically by lefthook** (see Setup above). Step 4 requires manual verification.

1. **Files staged?** Run `git status`. Confirm only intended files are staged. No secrets (`.env`,
   credentials). No files belonging to another feature. _(Secrets check enforced by `pre-commit`
   hook.)_
2. **Compiles?** Run `cargo build`. Must succeed. _(Enforced by `pre-commit` hook.)_
3. **Message format?** Confirm the commit message matches `<type>(<scope>): <summary>` with valid
   type and scope from the tables above. Subject line is imperative, lowercase, no period, max 72
   characters. _(Enforced by `commit-msg` hook.)_
4. **Specs with code?** If the commit includes changes to `src/contracts/`, confirm matching
   `.specs/contracts/` changes are also staged. If the commit includes a new system or component,
   confirm `.specs/features/<name>/spec.md` is up to date. _(Manual — not automated.)_

If any check fails (hook rejection or manual verification), fix the issue before committing.

---

## Merging to Mainline

Merging a feature branch to `main` is a deliberate act. Only one merge may be in progress at a time,
coordinated through the **Merge Lock** in `.specs/coordination.md`.

### Merge Lock Protocol

Before starting a merge, you **must** claim the merge lock:

1. **Check the lock.** Read `.specs/coordination.md` → Merge Lock table. If any row has status
   `merging`, **stop and wait**. Do not proceed until the lock is clear.
2. **Claim the lock.** Add a row with your branch, the version you intend to use (determined from
   the Version Lookup Table), your session identifier, and status `merging`.
3. **Proceed with the Pre-Merge Checklist** below.
4. **Release the lock.** After the tag is created and verified, update your row's status to `done`.

If a row has been `merging` for an unreasonable time (e.g., the owning session is no longer active),
investigate before overriding. Do not silently clear another session's lock.

### Pre-Merge Checklist

Every merge to `main` must pass all of these in order:

1. **Merge lock claimed?** Confirm your row is in the Merge Lock table with status `merging` and no
   other row is also `merging`. If you skipped the lock protocol above, stop and go back.
2. **Tests pass?** Run `cargo test`. All tests must pass.
3. **Lint clean?** Run `cargo clippy -- -D warnings`. Zero warnings.
4. **Compiles clean?** Run `cargo build`. No warnings or errors.
5. **Constitution audit?** Run the boundary check from CLAUDE.md Development Workflow step 7. Zero
   violations.
6. **Scope verified?** Run `git diff main --name-only`. Every changed file must belong to one of
   these categories:
   - Your feature's module: `src/<feature>/**`
   - Your feature's specs: `.specs/features/<feature>/**`
   - Contracts your feature owns or extends: `src/contracts/**`, `.specs/contracts/**`
   - Expected shared files: `.specs/coordination.md`, `Cargo.toml`, `Cargo.lock`, `main.rs` (plugin
     registration)
   - If any file falls outside these categories, investigate. Either remove the change or justify it
     in the commit body.
7. **Spec criteria met?** Open `.specs/features/<name>/spec.md`. Every success criterion is
   satisfied.
8. **Rebased?** Run `git log --oneline main..<branch>`. Confirm the branch is based on current
   `main` tip. If not, rebase first: `git rebase main`. If the rebase produces conflicts, follow the
   Conflict Resolution rules below.
9. **Re-test after rebase?** Run `cargo test` and `cargo clippy -- -D warnings` again. The rebase
   may have introduced conflicts or breakage not caught earlier. Both must pass before proceeding.
10. **Version bumped?** Determine the correct next version (see Version Lookup Table below). Update
    the `version` field in `Cargo.toml`. Strip the pre-release suffix (e.g., `0.4.0-unit` becomes
    `0.4.0`).
11. **Merge.** From `main`: `git merge <branch>`.
12. **Generate changelog.** Run `git cliff --output CHANGELOG.md`. Review the generated output to
    confirm it's accurate. Make manual edits only if a commit message was unclear.
13. **Version commit.** Stage `Cargo.toml` and `CHANGELOG.md`, commit:
    `chore(project): bump version to <version>`.
14. **Tag.** Create annotated tag: `git tag -a v<version> -m "<milestone>: <milestone title>"`.
15. **Verify.** Run `git log --oneline -5` and `git tag -l` to confirm the merge, commit, and tag
    are correct.
16. **Release lock.** Update your Merge Lock row in `.specs/coordination.md` to status `done`.

### Milestone final merge

When the last feature of a milestone merges, also:

17. **Milestone checkpoint audit.** Run the full Milestone Completion Gate from CLAUDE.md (all 10
    checks).
18. **Record in coordination.** Add the audit result and tag to `.specs/coordination.md` under
    Integration Test Checkpoints.

### Conflict Resolution

When rebasing onto `main` produces merge conflicts, resolve them by file type:

**`src/contracts/` (shared types)**

1. Accept the version already on `main` — it was merged first and other features may depend on it.
2. Re-apply your additions on top. Do not remove or rename types that the other branch introduced.
3. Update your feature's code to work with the merged contract state.
4. If the conflict is structural (incompatible type changes), stop the rebase (`git rebase --abort`)
   and coordinate via `.specs/coordination.md` Pending Contract Changes before proceeding.

**`.specs/coordination.md` (shared coordination state)**

1. Accept the `main` version of the table rows.
2. Re-apply only your row updates (ownership, status).
3. Never overwrite another session's rows or status.

**`CHANGELOG.md`**

1. Accept the `main` version (which includes the other branch's entry).
2. Add your entry above it (newest first).

**`Cargo.toml` (version field)**

1. Accept the `main` version.
2. Your version bump happens in Pre-Merge Checklist step 10, after the rebase — so the conflict here
   is between your pre-release suffix and the merged release version. Take the merged version;
   you'll set the final version in step 10.

**`src/<feature>/` (your own feature code)**

1. If `main` changed your feature's files (unlikely in the worktree model), investigate why. Another
   session should not be modifying your feature.
2. If the conflict is in shared infrastructure (e.g., `main.rs` plugin registration), accept
   `main`'s additions and add yours alongside.

**General rules:**

- Never silently drop the other branch's changes to resolve a conflict.
- After resolving all conflicts, run `cargo build` and `cargo test` before continuing the rebase.
- If a conflict is too complex to resolve confidently, abort the rebase and coordinate with the
  other session.

### Cross-Branch Integration Testing

When two in-flight feature branches have interdependent contracts or need to be validated together
before either merges to `main`, use a **temporary integration branch**:

1. **Create a throwaway branch** from `main`:
   ```bash
   git branch integration-test main
   git worktree add ../hexorder-integration-test integration-test
   cd ../hexorder-integration-test
   ```
2. **Merge both feature branches** into it:
   ```bash
   git merge m4/movement-rules
   git merge m4/terrain-costs
   ```
3. **Resolve any conflicts** between the two branches (follow the Conflict Resolution rules above).
4. **Run the full test suite**:
   ```bash
   cargo build && cargo test && cargo clippy -- -D warnings
   ```
5. **Evaluate results.** If tests pass, both features are compatible — proceed with merging them to
   `main` individually (one at a time, via the normal Pre-Merge Checklist). If tests fail, the
   failing feature must fix its code on its own branch before retesting.
6. **Discard the integration branch** — it is never merged to `main`:
   ```bash
   cd ../hexorder
   git worktree remove ../hexorder-integration-test
   git branch -D integration-test
   ```

This branch exists solely for testing. It carries no version bump, no changelog entry, and no tag.
The real merges happen through the normal Pre-Merge Checklist.

---

## Versioning

Hexorder follows **semantic versioning** (`MAJOR.MINOR.PATCH`) with milestones driving minor
versions.

| Version           | Meaning                                                              |
| ----------------- | -------------------------------------------------------------------- |
| `0.x.0`           | Milestone release (M1 = `0.1.0`, M2 = `0.2.0`, etc.)                 |
| `0.x.y`           | Patch within a milestone (bug fixes, small additions post-milestone) |
| `0.x.0-<feature>` | Pre-release on a feature branch (e.g., `0.4.0-movement-rules`)       |
| `1.0.0`           | First production-quality release (future)                            |

The `0.x` series signals pre-release. Breaking changes are expected between milestones.

### Pre-release versions on feature branches

While working on a feature branch, `Cargo.toml` carries a **pre-release suffix**:

```
0.4.0-movement-rules
```

- The suffix is the `<feature>` portion of the branch name
- This is valid semver — Cargo and tooling recognize it as a pre-release
- The suffix identifies which branch produced a given build
- The suffix is **stripped at merge time** when the version is set to its final `0.x.0` or `0.x.y`
  form in the Pre-Merge Checklist

### Version Lookup Table

This table is the **single source of truth** for version assignment. Update it when a new milestone
begins.

| Milestone | Version | Tag      | Title                    |
| --------- | ------- | -------- | ------------------------ |
| M1        | `0.1.0` | `v0.1.0` | The World Exists         |
| M2        | `0.2.0` | `v0.2.0` | The World Has Properties |
| M3        | `0.3.0` | `v0.3.0` | Things Live in the World |
| M4        | `0.4.0` | `v0.4.0` | Rules Shape the World    |
| M5        | `0.5.0` | `v0.5.0` | The World Remembers      |

To determine the next version for a merge:

1. Look up the current milestone in the table above.
2. If this is the first or only merge for the milestone, use `0.x.0`.
3. If a `0.x.0` tag already exists for this milestone, increment the patch: `0.x.1`, `0.x.2`, etc.

---

## Tags

Every merge to `main` that bumps the version gets an **annotated** tag:

```bash
git tag -a v0.3.0 -m "M3: Things Live in the World"
```

Tag message format: `<milestone>: <milestone title>` for milestone releases, or
`<milestone>: <brief description>` for patches.

---

## Changelog Format

`CHANGELOG.md` is **auto-generated** by [git-cliff](https://git-cliff.org/) from conventional commit
messages. Configuration lives in `cliff.toml` at the project root.

### Generation

```bash
git cliff --output CHANGELOG.md          # regenerate full changelog from all tags
git cliff --latest --output CHANGELOG.md # regenerate only the latest version
git cliff --unreleased                   # preview unreleased changes (stdout)
```

The generated format follows [Keep a Changelog](https://keepachangelog.com/):

```markdown
## [0.4.0] — 2026-02-15

### Added

- add unit placement and movement systems (unit)
- add unit type contract spec (contracts)

### Fixed

- prevent panel click from painting cells (editor_ui)

### Changed

- bump version to 0.4.0 (project)
```

### How commit messages map to changelog entries

| Commit type | Changelog group |
| ----------- | --------------- |
| `feat`      | Added           |
| `test`      | Added           |
| `docs`      | Added           |
| `fix`       | Fixed           |
| `refactor`  | Changed         |
| `style`     | Changed         |
| `chore`     | Changed         |

The commit scope becomes the parenthetical at the end of each entry.

### Manual edits

After generating, review the output. If a commit message was unclear or needs correction, edit
`CHANGELOG.md` directly. Prefer fixing the commit message convention going forward rather than
habitually hand-editing.

### Rules

- Never hand-write changelog entries from scratch — always generate first, then review
- The changelog is regenerated on every merge to `main` (Pre-Merge Checklist step 12)
- Versions are listed in reverse chronological order (newest first)

---

## Session Handoff Protocol

When a new Claude Code session picks up work on an existing feature branch, run these steps before
doing anything else:

1. **Check for orphaned worktrees.** Run `git worktree list`. If there are worktrees from a prior
   session that is no longer active:
   - `cd` into the orphaned worktree and run `git status`.
   - If there are uncommitted changes, evaluate them: commit coherent work with a checkpoint commit
     (`chore(<feature>): recover uncommitted work from prior session`), or discard broken fragments
     with `git checkout -- .`.
   - If the worktree is for a different feature than yours, leave it alone — another session may own
     it.
   - If the worktree is for your feature, continue working in it. If you need a fresh worktree,
     clean up the orphan first: `git worktree remove <path>`.
2. **Identify the branch.** Run `git branch --show-current` to confirm you're on the correct feature
   branch.
3. **Check for uncommitted work.** Run `git status`. If there are unstaged or staged changes from a
   prior session, review them. Commit coherent work; discard broken fragments.
4. **Review branch history.** Run `git log --oneline main..HEAD` to see what the previous session(s)
   committed on this branch. Use the conventional commit format to reconstruct context:
   - **Group by type** to understand what was done: `feat` = new functionality, `fix` = bug fixes,
     `refactor` = restructuring, `test` = test additions, `docs` = spec/doc updates, `chore` =
     setup/config.
   - **Group by scope** to understand what was touched: each scope maps to a feature module or
     `contracts`/`project`.
   - **Read commit bodies** (run `git log main..HEAD` without `--oneline`) for rationale and
     decisions — these serve as lightweight decision records between log entries.
   - **Identify the last checkpoint commit** (if any) — this marks the last known-good state the
     prior session saved before a risky change.
5. **Load context from diff.** Run `git diff main..HEAD --stat` for a file-level summary, then
   `git diff main..HEAD` for the full delta. This is the fastest way to understand what this branch
   has changed relative to mainline.
6. **Read the spec and log.** Open `.specs/features/<name>/spec.md` and
   `.specs/features/<name>/log.md`. The log records decisions, blockers, and test results from prior
   sessions.
7. **Check coordination.** Read `.specs/coordination.md` for any contract changes or blockers that
   appeared since the last session.
8. **Resume the Development Workflow.** Pick up from the appropriate step in CLAUDE.md's Development
   Workflow based on what the prior session completed.

This protocol ensures no prior work is lost or duplicated, and the new session starts with full
context from git history + specs.

---

## Agent-Specific Rules

When a Claude Code session needs to commit:

1. **Read this guide first** — follow the message format and conventions
2. **Run the Pre-Commit Checklist** (above) for every commit
3. **Run the Pre-Merge Checklist** (above) for every merge to `main`
4. **Never force-push to `main`**
5. **Never commit secrets** (`.env`, credentials, API keys)
6. **Commit specs and code together** — a contract spec and its Rust implementation belong in the
   same commit
7. **Use the worktree for your feature** — don't commit other features' work
8. **When in doubt, commit** — it's easier to squash later than to recover lost work
9. **Multi-terminal coordination**: each session works in its own worktree on its own branch
10. **Merge lock**: always claim the Merge Lock in `.specs/coordination.md` before starting a merge
    to `main` — never merge without holding the lock
