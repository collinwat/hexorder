# Hexorder — Git Guide

## Strategy

Hexorder uses **trunk-based development with worktrees**, operating within Shape Up build cycles.

The `main` branch is the mainline — it must always compile, pass tests, and represent a shippable
state. Feature work happens on short-lived branches via git worktrees, merged back to `main` when
the cycle's scope is complete.

Build cycles have fixed time and variable scope. Branches are created within a cycle to implement
shaped pitches. At the end of the cycle, completed work ships.

- Small, frequent commits on feature branches
- Deliberate merges to mainline with version bump and changelog
- Every merge tagged with an annotated version tag

---

## Setup

Project tooling is managed by [mise](https://mise.jdx.dev/). Git hooks are managed by
[lefthook](https://github.com/evilmartians/lefthook). Changelogs are generated by
[git-cliff](https://git-cliff.org/).

### First-time setup

```bash
mise setup      # installs tools, configures git-lfs and hooks
```

Or manually:

```bash
mise install        # installs lefthook, git-lfs, and any other project tools
git lfs install     # configures git-lfs for this user (once per machine)
lefthook install    # installs git hooks into .git/hooks/
```

### What the hooks enforce

| Hook         | What it checks                                                                                            |
| ------------ | --------------------------------------------------------------------------------------------------------- |
| `commit-msg` | Message matches `<type>(<scope>): <summary>` with valid types and scopes. Subject line max 72 characters. |
| `pre-commit` | No secrets staged (`.env`, credentials, keys). Code compiles (`cargo check`). Formatting is correct.      |

These hooks are the automated enforcement of the Pre-Commit Checklist. If a hook rejects your
commit, fix the issue — do not bypass with `--no-verify`.

### Git LFS

Binary assets (images, fonts, audio, 3D models) are tracked by Git LFS to prevent repo bloat.
Tracked patterns are defined in `.gitattributes` at the project root.

When adding a **new binary file type** to the project, add a corresponding LFS tracking rule to
`.gitattributes` before committing the files.

### Configuration

- `mise.toml` — declares project tools (lefthook, git-lfs, git-cliff)
- `lefthook.yml` — defines hook commands and validation rules
- `cliff.toml` — defines changelog generation template and commit parsers
- `.gitattributes` — defines Git LFS tracking patterns for binary assets

When adding a new plugin scope (e.g., a new plugin module), update the scope regex in
`lefthook.yml`'s `commit-msg` hook to include it.

---

## Branching

### Mainline: `main`

- Always builds (`cargo build` clean)
- Always passes tests (`cargo test`) and lint (`cargo clippy -- -D warnings`)
- Every merge to `main` is tagged with a release version
- Direct commits to `main` are limited to project-level config and documentation (e.g., CLAUDE.md,
  docs/, docs/ process files)

### Integration branch

Each build cycle has an **integration branch** that collects completed pitch work before it merges
to `main`. This replaces the merge lock protocol from earlier cycles.

```
main ──●──────────────────────────────────────●── (tagged release)
        \                                    /
         0.8.0 ──●──────●──────●────────────●  (integration branch)
                  \     / \   /
                   feat-A   feat-B              (pitch branches)
```

- **Created at cycle start** by the first agent to kick off. Named `<version>` (e.g., `0.8.0`).
- **Pitch branches** are created from the integration branch, not from `main`.
- **Pitch merges** go into the integration branch (merge, not rebase). No lock needed — pitches
  merge independently as they finish.
- **Ship merge** is one merge from the integration branch to `main`, with one tag and one changelog.

For **solo-pitch cycles** (only one pitch), the integration branch is optional. The pitch branch can
merge directly to `main` using the Pre-Merge Checklist as before.

### Feature branches

- One branch per plugin or release task
- Use **git worktrees** (under `.worktrees/`) so each plugin gets its own working directory,
  allowing parallel development without stashing or switching
- Keep branches short-lived — merge when the plugin passes its spec criteria and tests
- Feature branches are created from the **integration branch** (multi-pitch cycles) or from `main`
  (solo-pitch cycles)

### Branch naming

Branch names **must** follow this pattern:

```
<release>/<feature>
```

- `<release>` is the target release version: `0.1.0`, `0.2.0`, `0.3.0`, etc.
- `<feature>` is the plugin name as it appears in `docs/coordination.md`, using hyphens for
  multi-word names

**Valid**: `0.3.0/unit`, `0.3.0/editor-ui`, `0.4.0/movement-rules` **Invalid**: `feature/unit`,
`unit-placement`, `m3_unit`, `0.3.0/Unit`

For non-plugin work (docs, process, tooling), use:

```
<release>/chore-<description>
```

**Valid**: `0.3.0/chore-git-guide`, `0.4.0/chore-ci-setup`

---

## Feature Branch Setup Checklist

Run these steps in order when starting work on a new plugin. No steps are optional.

1. **Branch name.** Determine the branch name: `<release>/<feature>` (e.g., `0.4.0/movement-rules`).
   Verify it follows the naming rules above.
2. **Create branch and worktree.** Worktrees live under `.worktrees/` in the project root. The
   directory name is the branch name with `/` replaced by `-`. Branch from the **integration
   branch** (multi-pitch cycles) or from `main` (solo-pitch cycles).
    ```bash
    git branch 0.4.0/movement-rules 0.4.0   # branch from integration branch
    git worktree add .worktrees/0.4.0-movement-rules 0.4.0/movement-rules
    cd .worktrees/0.4.0-movement-rules
    ```
3. **Install hooks in worktree.** Run `lefthook install` in the new worktree directory. Worktrees
   have their own git hooks and need lefthook installed separately.
4. **Set pre-release version.** Edit `Cargo.toml` and append a pre-release suffix to the version:
    ```toml
    version = "0.4.0-movement-rules"
    ```
    The suffix is the `<feature>` portion of the branch name. This identifies builds from this
    branch. The suffix is stripped at merge time when the final version is set.
5. **Spec scaffolding.** Verify the plugin has spec and log files. If they don't exist, create them
   from the templates:
    ```
    docs/plugins/<plugin>/spec.md   ← copy from docs/guides/plugin.md
    docs/plugins/<plugin>/log.md    ← copy from docs/guides/plugin.md
    ```
    If the files already exist, read them to understand prior decisions.
6. **Contract check.** Read `docs/contracts/` for any shared types the plugin depends on or
   introduces. If new contracts are needed, follow the Shared Contracts Protocol in CLAUDE.md.
7. **Claim ownership.** Update `docs/coordination.md` → Active Plugins table: set Owner to your
   session identifier and Status to `in-progress`.
8. **Initial commit.** Stage the `Cargo.toml` version change, any new spec/log files, and the
   coordination.md update. Commit:

    ```
    chore(<feature>): set up feature branch

    Create worktree, set pre-release version, scaffold specs.
    Part of <release>.
    ```

After this checklist, proceed to the Development Workflow in CLAUDE.md.

---

## Feature Branch Teardown Checklist

Run these steps after a feature branch has been merged to `main` and the merge tag is verified.

1. **Verify merge.** Confirm the merge commit and tag exist on `main`:
    ```bash
    git log --oneline -5 main
    git tag -l 'v0.*'
    ```
2. **Remove worktree.**
    ```bash
    git worktree remove .worktrees/<release>-<feature>
    ```
3. **Delete branch.**
    ```bash
    git branch -d <release>/<feature>
    ```
4. **Update ownership.** In `docs/coordination.md` → Active Plugins table, set Status to `complete`
   and clear Owner.
5. **Verify clean state.** Run `git worktree list` and confirm only the main worktree remains (plus
   any other active plugin worktrees).

---

## Commits

### Commit early and often

- Commit whenever you reach a coherent working state — a system compiles, a test passes, a contract
  is defined
- Small, frequent commits are preferred over large, infrequent ones
- **Every commit must compile.** `cargo check` must succeed before committing. This is enforced by
  the `pre-commit` hook and keeps history bisect-friendly — `git bisect` can binary-search any
  regression across the commit history
- Incomplete work is fine on feature branches as long as it compiles; the merge to `main` is what
  matters for test quality
- Specs, contracts, and code for the same change travel together in the same commit

### Checkpoint commits

Before attempting a risky change (large refactor, contract modification, deleting significant code),
commit the current known-good state as a checkpoint:

```
chore(<feature>): checkpoint before <description>
```

Examples:

```
chore(unit): checkpoint before movement system refactor
chore(contracts): checkpoint before adding unit stacking types
```

This gives a clean rollback point. If the risky change fails or goes wrong:

```bash
git reset --hard HEAD~<n>   # roll back to the checkpoint
```

Checkpoint commits are normal commits — they travel with the branch and get merged. They're cheap
insurance against lost work, especially for agents that can't interactively undo edits.

### Commit message format

Follow **conventional commit** practices. Every commit message **must** match this structure:

```
<type>(<scope>): <summary>

<optional body>
```

**Types** — use exactly one of:

| Type       | When to use                                                   |
| ---------- | ------------------------------------------------------------- |
| `feat`     | New functionality (system, component, plugin, UI element)     |
| `fix`      | Bug fix                                                       |
| `refactor` | Code restructuring with no behavior change                    |
| `test`     | Adding or updating tests only                                 |
| `docs`     | Documentation, specs, logs, guides                            |
| `chore`    | Build config, version bumps, tooling, cleanup                 |
| `style`    | Formatting, whitespace, brand/theme changes (no logic change) |

**Scope** — use exactly one of:

| Scope       | When to use                                                                                    |
| ----------- | ---------------------------------------------------------------------------------------------- |
| Plugin name | Work within a single plugin (`unit`, `cell`, `hex_grid`, `camera`, `game_system`, `editor_ui`) |
| `contracts` | Shared type definitions in `src/contracts/` or `docs/contracts/`                               |
| `project`   | Cross-cutting changes (CLAUDE.md, coordination, git guide, build config)                       |

**Subject line rules**:

- Imperative mood ("add", not "added" or "adds")
- Lowercase (no capital first letter)
- No trailing period
- Maximum 72 characters total (including type and scope)

**Body rules** (when present):

- Separated from subject by one blank line
- Wrap at 72 characters
- Explain _why_, not _what_ — the diff shows what changed
- Reference the release when relevant: "Part of 0.3.0"

**Examples**:

```
feat(unit): add unit placement and movement systems

Implements UnitPlugin with spawn, move, delete, and visual sync systems.
Adds 9 unit tests and 4 integration tests. Part of 0.3.0.
```

```
docs(contracts): add unit type contract spec

Defines UnitType, UnitData, UnitInstance, and UnitPlacedEvent shared
types for 0.3.0. Matches src/contracts/game_system.rs additions.
```

```
fix(editor_ui): prevent panel click from painting cells

Guard cell painting systems with egui_wants_any_pointer_input check.
```

```
chore(project): bump version to 0.3.0
```

---

## Pre-Commit Checklist

**Every commit** on a feature branch must pass this checklist. Steps 1-3 are **enforced
automatically by lefthook** (see Setup above). Step 4 requires manual verification.

1. **Files staged?** Run `git status`. Confirm only intended files are staged. No secrets (`.env`,
   credentials). No files belonging to another plugin. _(Secrets check enforced by `pre-commit`
   hook.)_
2. **Compiles?** Run `cargo check`. Must succeed. _(Enforced by `pre-commit` hook.)_
3. **Message format?** Confirm the commit message matches `<type>(<scope>): <summary>` with valid
   type and scope from the tables above. Subject line is imperative, lowercase, no period, max 72
   characters. _(Enforced by `commit-msg` hook.)_
4. **Specs with code?** If the commit includes changes to `src/contracts/`, confirm matching
   `docs/contracts/` changes are also staged. If the commit includes a new system or component,
   confirm `docs/plugins/<name>/spec.md` is up to date. _(Manual — not automated.)_

If any check fails (hook rejection or manual verification), fix the issue before committing.

---

## Merging

### Pitch Merge (feature branch → integration branch)

When a pitch finishes its scope, merge it into the integration branch. No lock is needed — pitches
merge independently.

1. **Quality gate?** Run `mise check:audit` on the feature branch. All checks must pass.
2. **Spec criteria met?** Every success criterion in `docs/plugins/<name>/spec.md` is satisfied.
3. **Deferred items captured?** Check spec and log for deferred items. Every item must have a
   corresponding GitHub Issue. Scan source code for TODO/FIXME comments — these must have
   corresponding issues or be removed.
4. **Merge into integration branch.** From the integration branch worktree:
    ```bash
    git merge <release>/<feature>
    ```
    Use a merge commit (not fast-forward, not rebase). If conflicts arise, follow the Conflict
    Resolution rules below.
5. **Re-test after merge?** Run `mise check:audit` on the integration branch. The merge may have
   introduced breakage. All checks must pass.
6. **Post retro comment.** Post a build reflection comment on the pitch issue (see CLAUDE.md →
   Progress Updates).

### Ship Merge (integration branch → main)

After all pitches merge into the integration branch and UAT passes, merge to `main`. This happens
once per cycle.

1. **All pitches merged?** Check `docs/coordination.md` — all bets should have status `merged`.
2. **UAT passed?** Walk through the UAT checklist (max 5 items per pitch). Record results as a
   comment on each pitch issue.
3. **Ship gate audit.** Run `mise check:audit` plus the manual checks from the Ship Gate in
   CLAUDE.md. If any check fails, fix and re-run.
4. **Version bumped?** Determine the correct next version (see Version Lookup Table below). Update
   `Cargo.toml`. Strip the pre-release suffix.
5. **Rebase onto main.** From the integration branch:
    ```bash
    git rebase main
    ```
    If conflicts arise, resolve and re-test with `mise check:audit`.
6. **Merge.** From `main`:
    ```bash
    git merge --ff-only <version>
    ```
7. **Generate changelog.** Run `mise changelog:generate`.
8. **Version commit.** Stage `Cargo.toml` and `CHANGELOG.md`, commit:
   `chore(project): bump version to <version>`.
9. **Tag.** Create annotated tag: `git tag -a v<version> -m "<release>: <title>"`.
10. **Verify.** Run `git log --oneline -5` and `git tag -l` to confirm the merge, commit, and tag.
11. **Push tag.** `git push origin main v<version>`.
12. **Create GitHub Release.**
    `gh release create v<version> --title "<release>: <title>" --notes-file CHANGELOG.md`
13. **Issue cleanup.** Close all GitHub Issues completed in this cycle:
    `gh issue list --milestone "<milestone>" --state open` — close each with
    `gh issue close <number> --reason completed`.
14. **Run cool-down protocol.** Run `/hex-cooldown` to start the retrospective, shaping, and betting
    for the next cycle.

### Solo-Pitch Merge (feature branch → main directly)

For cycles with only one pitch, the integration branch is optional. Use this simplified flow:

1. **Quality gate?** Run `mise check:audit`. All checks must pass.
2. **Spec criteria met?** Every success criterion satisfied.
3. **Deferred items captured?** All deferred items have GitHub Issues.
4. **Rebased?** `git rebase main`. Re-test with `mise check:audit`.
5. **Merge.** `git merge --ff-only <branch>`.
6. **Generate changelog.** `mise changelog:generate`.
7. **Version commit + tag + push.** Same as Ship Merge steps 8-12.
8. **Issue cleanup + cool-down.** Same as Ship Merge steps 13-14.

### Conflict Resolution

When rebasing onto `main` produces merge conflicts, resolve them by file type:

**`src/contracts/` (shared types)**

1. Accept the version already on `main` — it was merged first and other plugins may depend on it.
2. Re-apply your additions on top. Do not remove or rename types that the other branch introduced.
3. Update your plugin's code to work with the merged contract state.
4. If the conflict is structural (incompatible type changes), stop the rebase (`git rebase --abort`)
   and coordinate via `docs/coordination.md` Pending Contract Changes before proceeding.

**`docs/coordination.md` (shared coordination state)**

1. Accept the `main` version of the table rows.
2. Re-apply only your row updates (ownership, status).
3. Never overwrite another session's rows or status.

**`CHANGELOG.md`**

1. Accept the `main` version (which includes the other branch's entry).
2. Add your entry above it (newest first).

**`Cargo.toml` (version field)**

1. Accept the `main` version.
2. Your version bump happens in Pre-Merge Checklist step 10, after the rebase — so the conflict here
   is between your pre-release suffix and the merged release version. Take the merged version;
   you'll set the final version in step 10.

**`src/<plugin>/` (your own plugin code)**

1. If `main` changed your plugin's files (unlikely in the worktree model), investigate why. Another
   session should not be modifying your plugin.
2. If the conflict is in shared infrastructure (e.g., `main.rs` plugin registration), accept
   `main`'s additions and add yours alongside.

**General rules:**

- Never silently drop the other branch's changes to resolve a conflict.
- After resolving all conflicts, run `cargo build` and `cargo test` before continuing the rebase.
- If a conflict is too complex to resolve confidently, abort the rebase and coordinate with the
  other session.

### Rollback

If a merge to `main` introduces a regression:

1. **Revert the merge commit**: `git revert -m 1 <merge-sha>`
2. **Tag the revert**: `git tag -a v<version>.1 -m "Revert: <reason>"`
3. **Push**: `git push origin main v<version>.1`
4. **Reopen the feature branch** to fix the issue
5. **Re-merge** following the normal Pre-Merge Checklist once the fix is verified

Do not delete or force-push tags. The revert creates a clean history record.

### Breaking Changes

For commits that introduce breaking changes, add a `BREAKING CHANGE:` footer to the commit body:

```
feat(game_system): replace PropertyValue with TypedValue

BREAKING CHANGE: PropertyValue enum variants renamed. All save files
using the old format must be migrated.
```

git-cliff renders these in a separate "Breaking Changes" section in the changelog. Include migration
steps in the commit body or a linked document.

---

## Versioning

Hexorder follows **semantic versioning** (`MAJOR.MINOR.PATCH`) with releases driving minor versions.

| Version           | Meaning                                                          |
| ----------------- | ---------------------------------------------------------------- |
| `0.x.0`           | Release (0.1.0, 0.2.0, etc.)                                     |
| `0.x.y`           | Patch within a release (bug fixes, small additions post-release) |
| `0.x.0-<feature>` | Pre-release on a feature branch (e.g., `0.4.0-movement-rules`)   |
| `1.0.0`           | First production-quality release (future)                        |

The `0.x` series signals pre-release. Breaking changes are expected between releases.

### Pre-release versions on feature branches

While working on a feature branch, `Cargo.toml` carries a **pre-release suffix**:

```
0.4.0-movement-rules
```

- The suffix is the `<feature>` portion of the branch name
- This is valid semver — Cargo and tooling recognize it as a pre-release
- The suffix identifies which branch produced a given build
- The suffix is **stripped at merge time** when the version is set to its final `0.x.0` or `0.x.y`
  form in the Pre-Merge Checklist

### Version Lookup Table

This table is the **single source of truth** for version assignment. Update it when a new release
begins.

| Release | Version | Tag      | Title                    |
| ------- | ------- | -------- | ------------------------ |
| 0.1.0   | `0.1.0` | `v0.1.0` | The World Exists         |
| 0.2.0   | `0.2.0` | `v0.2.0` | The World Has Properties |
| 0.3.0   | `0.3.0` | `v0.3.0` | Things Live in the World |
| 0.4.0   | `0.4.0` | `v0.4.0` | Rules Shape the World    |
| 0.5.0   | `0.5.0` | `v0.5.0` | The World Remembers      |
| 0.6.0   | `0.6.0` | `v0.6.0` | The World Has Identity   |
| 0.7.0   | `0.7.0` | `v0.7.0` | The World Has Structure  |
| 0.8.0   | `0.8.0` | `v0.8.0` | Process Reform           |

To determine the next version for a merge:

1. Look up the current release in the table above.
2. If this is the first or only merge for the release, use `0.x.0`.
3. If a `0.x.0` tag already exists for this release, increment the patch: `0.x.1`, `0.x.2`, etc.

---

## Tags

Every merge to `main` that bumps the version gets an **annotated** tag:

```bash
git tag -a v0.3.0 -m "0.3.0: Things Live in the World"
```

Tag message format: `<release>: <title>` for releases, or `<release>: <brief description>` for
patches.

---

## Changelog Format

`CHANGELOG.md` is **auto-generated** by [git-cliff](https://git-cliff.org/) from conventional commit
messages. Configuration lives in `cliff.toml` at the project root.

### Generation

```bash
mise changelog:generate              # regenerate full changelog from all tags
mise changelog                       # preview unreleased changes (stdout)
git cliff --latest --output CHANGELOG.md # regenerate only the latest version
```

The generated format follows [Keep a Changelog](https://keepachangelog.com/):

```markdown
## [0.4.0] — 2026-02-15

### Added

- add unit placement and movement systems (unit)
- add unit type contract spec (contracts)

### Fixed

- prevent panel click from painting cells (editor_ui)

### Changed

- bump version to 0.4.0 (project)
```

### How commit messages map to changelog entries

| Commit type | Changelog group |
| ----------- | --------------- |
| `feat`      | Added           |
| `test`      | Added           |
| `docs`      | Added           |
| `fix`       | Fixed           |
| `refactor`  | Changed         |
| `style`     | Changed         |
| `chore`     | Changed         |

The commit scope becomes the parenthetical at the end of each entry.

### Manual edits

After generating, review the output. If a commit message was unclear or needs correction, edit
`CHANGELOG.md` directly. Prefer fixing the commit message convention going forward rather than
habitually hand-editing.

### Edge cases

**Malformed commits**: If a commit doesn't match `type(scope): summary`, git-cliff will skip it. The
entry won't appear in the generated changelog. Fix by amending the commit message (if not yet
pushed) or noting the omission in a manual edit after generation.

**Regeneration safety**: `mise changelog:generate` regenerates the full changelog from all tags. It
is safe to run repeatedly — git-cliff reads from git history, not from the existing `CHANGELOG.md`.
Any manual edits to `CHANGELOG.md` will be overwritten on the next regeneration.

**Breaking changes**: Commit messages with a `BREAKING CHANGE:` footer are rendered in a separate
section (see Breaking changes under Commits above). Always include migration steps in the commit
body.

### Rules

- Never hand-write changelog entries from scratch — always generate first, then review
- The changelog is regenerated on every ship merge to `main` (Ship Merge step 7)
- Versions are listed in reverse chronological order (newest first)

---

## Design Document Lifecycle

Design documents live in `docs/plans/` and are created during the orientation phase of a build
cycle. They capture implementation plans, architecture decisions, and design rationale.

### Lifecycle

| Phase                     | Status     | Source of Truth                                               |
| ------------------------- | ---------- | ------------------------------------------------------------- |
| **During implementation** | Active     | The design doc is the reference for approach and decisions    |
| **After implementation**  | Historical | The code, specs, contracts, and plugin logs are authoritative |

### After Implementation

When a pitch ships, the design doc becomes historical. Before marking it as such:

1. **Propagate key decisions** into permanent docs:
    - Architecture decisions → `docs/architecture.md` or plugin spec
    - Contract decisions → `docs/contracts/<name>.md`
    - Process learnings → plugin log or relevant guide
    - Deferred items → GitHub Issues
2. **Mark the design doc as historical** by adding a header at the top:
    ```markdown
    > **Historical** — Implemented in v0.x.0. The code, plugin specs, and contracts are now
    > authoritative. This document is preserved for context on why decisions were made.
    ```
3. Do not delete design docs — they serve as a record of _why_ decisions were made, which the
   permanent docs may not capture.

### Naming Convention

Design docs follow the pattern: `<date>-<feature-name>.md` or `<date>-<feature-name>-design.md` for
architecture-focused docs.

---

## Session Handoff Protocol

When a new Claude Code session picks up work on an existing feature branch, run these steps before
doing anything else.

**Quick start**: Run `mise handoff` to get a snapshot of worktrees, branch, status, commits, and
changed files. Then continue with the detailed steps below for anything that needs attention.

1. **Check for orphaned worktrees.** Run `git worktree list`. If there are worktrees from a prior
   session that is no longer active:
    - `cd` into the orphaned worktree and run `git status`.
    - If there are uncommitted changes, evaluate them: commit coherent work with a checkpoint commit
      (`chore(<feature>): recover uncommitted work from prior session`), or discard broken fragments
      with `git checkout -- .`.
    - If the worktree is for a different plugin than yours, leave it alone — another session may own
      it.
    - If the worktree is for your plugin, continue working in it. If you need a fresh worktree,
      clean up the orphan first: `git worktree remove <path>`.
2. **Identify the branch.** Run `git branch --show-current` to confirm you're on the correct feature
   branch.
3. **Check for uncommitted work.** Run `git status`. If there are unstaged or staged changes from a
   prior session, review them. Commit coherent work; discard broken fragments.
4. **Review branch history.** Run `git log --oneline main..HEAD` to see what the previous session(s)
   committed on this branch. Use the conventional commit format to reconstruct context:
    - **Group by type** to understand what was done: `feat` = new functionality, `fix` = bug fixes,
      `refactor` = restructuring, `test` = test additions, `docs` = spec/doc updates, `chore` =
      setup/config.
    - **Group by scope** to understand what was touched: each scope maps to a plugin module or
      `contracts`/`project`.
    - **Read commit bodies** (run `git log main..HEAD` without `--oneline`) for rationale and
      decisions — these serve as lightweight decision records between log entries.
    - **Identify the last checkpoint commit** (if any) — this marks the last known-good state the
      prior session saved before a risky change.
5. **Load context from diff.** Run `git diff main..HEAD --stat` for a file-level summary, then
   `git diff main..HEAD` for the full delta. This is the fastest way to understand what this branch
   has changed relative to mainline.
6. **Read the spec and log.** Open `docs/plugins/<name>/spec.md` and `docs/plugins/<name>/log.md`.
   The log records decisions, blockers, and test results from prior sessions.
7. **Check coordination.** Read `docs/coordination.md` for any contract changes or blockers that
   appeared since the last session.
8. **Resume the Development Workflow.** Pick up from the appropriate step in CLAUDE.md's Development
   Workflow based on what the prior session completed.

This protocol ensures no prior work is lost or duplicated, and the new session starts with full
context from git history + specs.

---

## Agent-Specific Rules

When a Claude Code session needs to commit:

1. **Read this guide first** — follow the message format and conventions
2. **Run the Pre-Commit Checklist** (above) for every commit
3. **Run the Pre-Merge Checklist** (above) for every merge to `main`
4. **Never force-push to `main`**
5. **Never commit secrets** (`.env`, credentials, API keys)
6. **Commit specs and code together** — a contract spec and its Rust implementation belong in the
   same commit
7. **Use the worktree for your plugin** — don't commit another plugin's work
8. **When in doubt, commit** — it's easier to squash later than to recover lost work
9. **Multi-terminal coordination**: each session works in its own worktree on its own branch
10. **Integration branch**: feature branches merge to the integration branch via Pitch Merge; only
    Ship Merge touches `main`
11. **Issue references**: reference GitHub Issue numbers in commits when closing or addressing
    tracked items (e.g., `fixes #42`, `ref #42`)
12. **Deferred items**: create GitHub Issues for deferred items before merge
13. **Duplicate check**: search existing issues before creating:
    `gh issue list --search "<keywords>" --state all`
