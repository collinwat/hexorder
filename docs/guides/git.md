# Hexorder — Git Guide

## Strategy

Hexorder uses **trunk-based development with worktrees**, operating within Shape Up build cycles.

The `main` branch is the mainline — it must always compile, pass tests, and represent a shippable
state. Feature work happens on short-lived branches via git worktrees, merged back to `main` when
the cycle's scope is complete.

Build cycles have fixed time and variable scope. Branches are created within a cycle to implement
shaped pitches. At the end of the cycle, completed work ships.

- Small, frequent commits on feature branches
- Deliberate merges to mainline with version bump and changelog
- Every merge tagged with an annotated version tag

---

## Setup

Project tooling is managed by [mise](https://mise.jdx.dev/). Git hooks are managed by
[lefthook](https://github.com/evilmartians/lefthook). Changelogs are generated by
[git-cliff](https://git-cliff.org/).

### First-time setup

```bash
mise setup      # installs tools, configures git-lfs and hooks
```

Or manually:

```bash
mise install        # installs lefthook, git-lfs, and any other project tools
git lfs install     # configures git-lfs for this user (once per machine)
lefthook install    # installs git hooks into .git/hooks/
```

### What the hooks enforce

| Hook         | What it checks                                                                                                                                                                            |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `commit-msg` | Message matches `<type>(<scope>): <summary>` with valid types and scopes. Subject line max 72 characters. Notices when `Cargo.lock` is staged without a dependency update commit message. |
| `pre-commit` | No secrets staged (`.env`, credentials, keys). Code compiles (`cargo check`). Formatting is correct.                                                                                      |

These hooks are the automated enforcement of the Pre-Commit Checklist. If a hook rejects your
commit, fix the issue — do not bypass with `--no-verify`.

### Git LFS

Binary assets (images, fonts, audio, 3D models) are tracked by Git LFS to prevent repo bloat.
Tracked patterns are defined in `.gitattributes` at the project root.

When adding a **new binary file type** to the project, add a corresponding LFS tracking rule to
`.gitattributes` before committing the files.

### Configuration

- `mise.toml` — declares project tools (lefthook, git-lfs, git-cliff)
- `lefthook.yml` — defines hook commands and validation rules
- `cliff.toml` — defines changelog generation template and commit parsers
- `.gitattributes` — defines Git LFS tracking patterns for binary assets

When adding a new plugin scope (e.g., a new plugin module), update the scope regex in
`lefthook.yml`'s `commit-msg` hook to include it.

---

## Branching

### Mainline: `main`

- Always builds (`cargo build` clean)
- Always passes tests (`cargo test`) and lint (`cargo clippy -- -D warnings`)
- Every merge to `main` is tagged with a release version
- Direct commits to `main` are limited to project-level config and documentation (e.g., CLAUDE.md,
  docs/, docs/ process files)

### Integration branch

Each build cycle has an **integration branch** that collects completed pitch work before it merges
to `main`. The cycle agent owns the integration branch; pitch agents own their feature branches.

> **Worktree invariant**: The main working tree always stays on `main`. The integration branch and
> all feature branches live in worktrees under `.worktrees/`. Never `git checkout` a non-main branch
> on the main working tree.

```
main ──●──────────────────────────────────────●── (tagged release)
        \                                    /
         0.8.0 ──●──●──●──●──●──●──●──●────●  (linear: feat-A then feat-B commits)
```

- **Created at cycle start** by the cycle agent. Named `<version>` (e.g., `0.8.0`). Follow the
  Integration Branch Setup Checklist below.
- **Pitch branches** are created from the integration branch, not from `main`.
- **Pitch integration** uses rebase + fast-forward to maintain linear history. The cycle agent
  rebases a ready pitch onto the integration branch, then fast-forward merges it.
- **Ship merge** is one fast-forward from the integration branch to `main`, with one tag and one
  changelog.

For **solo-pitch cycles** (only one pitch), the integration branch is optional. The pitch branch can
merge directly to `main` using the Pre-Merge Checklist as before.

### Feature branches

- One branch per plugin or release task
- Use **git worktrees** (under `.worktrees/`) so each plugin gets its own working directory,
  allowing parallel development without stashing or switching
- Keep branches short-lived — merge when the plugin passes its spec criteria and tests
- Feature branches are created from the **integration branch** (multi-pitch cycles) or from `main`
  (solo-pitch cycles)

> **Shared target directory**: All worktrees under the same repository share `<repo-root>/target/`.
> Incremental compilation artifacts from one worktree may become invalid when another worktree
> builds with different features or dependency versions. If you encounter unexplained crashes after
> switching worktrees, run `cargo clean -p hexorder` to clear stale artifacts without wiping the
> entire dependency cache. See `/hex-bisect` for the full triage workflow.

### Branch naming

Branch names **must** follow this pattern:

```
<release>-<feature>
```

- `<release>` is the target release version: `0.1.0`, `0.2.0`, `0.3.0`, etc.
- `<feature>` is the plugin name as it appears under `src/`, using hyphens for multi-word names
- The separator is a **hyphen**, not a slash

**Valid**: `0.3.0-unit`, `0.3.0-editor-ui`, `0.4.0-movement-rules` **Invalid**: `feature/unit`,
`unit-placement`, `m3_unit`, `0.3.0/Unit`, `0.3.0/editor-ui`

For non-plugin work (docs, process, tooling), use:

```
<release>-chore-<description>
```

**Valid**: `0.3.0-chore-git-guide`, `0.4.0-chore-ci-setup`

> **Why hyphens, not slashes?** Git refs are path-based. The integration branch `0.9.0` lives at
> `refs/heads/0.9.0`. A feature branch named `0.9.0/editor-ui` would require
> `refs/heads/0.9.0/editor-ui` — but git cannot use `0.9.0` as both a file (the integration branch)
> and a directory (the feature branch prefix) simultaneously. Pushes and fetches fail with
> `cannot lock ref` errors. Hyphens avoid this entirely because `refs/heads/0.9.0-editor-ui` is a
> sibling of `refs/heads/0.9.0`, not a child. As a bonus, the branch name now matches the worktree
> directory name exactly.

---

## Feature Branch Setup Checklist

Run these steps in order when starting work on a new plugin. No steps are optional.

1. **Branch name.** Determine the branch name: `<release>-<feature>` (e.g., `0.4.0-movement-rules`).
   Verify it follows the naming rules above.
2. **Create branch and worktree.** Worktrees live under `.worktrees/` in the project root. The
   directory name matches the branch name. Branch from the **integration branch** (multi-pitch
   cycles) or from `main` (solo-pitch cycles).

    ```bash
    git branch 0.4.0-movement-rules 0.4.0   # branch from integration branch
    git worktree add .worktrees/0.4.0-movement-rules 0.4.0-movement-rules
    cd .worktrees/0.4.0-movement-rules
    ```

    > **Do NOT run `cargo update`.** The feature branch inherits the parent's `Cargo.lock`. Running
    > `cargo update` bumps transitive dependencies that may introduce runtime crashes invisible to
    > `cargo test` (e.g., Metal/GPU driver incompatibilities on macOS). If a dependency update is
    > genuinely needed, do it as a separate commit with message
    > `chore(project): update dependencies` so the lefthook guard recognizes it as intentional.

3. **Install hooks in worktree.** Run `lefthook install` in the new worktree directory. Worktrees
   have their own git hooks and need lefthook installed separately.
4. **Trust the worktree.** Mise and Claude Code use path-based trust that does not cascade from the
   main repo to worktrees. Run these in the new worktree directory:
    ```bash
    mise trust                  # trust mise.toml in this worktree
    cp ../../.claude/settings.local.json .claude/settings.local.json  # copy Claude Code permissions
    ```
    Without `mise trust`, mise will refuse to activate tools and tasks. Without copying
    `settings.local.json`, Claude Code starts with minimal permissions and re-prompts for every
    previously approved action.
5. **Format the codebase.** Run `cargo fmt`. If any files change, stage and commit as
   `style(<feature>): apply formatting baseline`. This prevents the pre-commit hook from rejecting
   your first real commit due to formatting changes in files you did not modify.
6. **Set pre-release version.** Edit `Cargo.toml` and set the version to `<release>-<feature>`,
   where `<release>` is the target release from the branch name (step 1), **not** the version
   currently in `Cargo.toml`:
    ```toml
    version = "0.4.0-movement-rules"
    ```
    The base version (`0.4.0`) comes from the branch name, not from the file — `Cargo.toml` may
    still carry the previous release's version. The suffix is the `<feature>` portion of the branch
    name. This identifies builds from this branch. The suffix is stripped at merge time when the
    final version is set.
7. **Spec scaffolding.** Verify the plugin has spec and log files. If they don't exist, create them
   from the templates:
    ```
    docs/plugins/<plugin>/spec.md   ← copy from docs/guides/plugin.md
    docs/plugins/<plugin>/log.md    ← copy from docs/guides/plugin.md
    ```
    If the files already exist, read them to understand prior decisions.
8. **Contract check.** Read `docs/contracts/` for any shared types the plugin depends on or
   introduces. If new contracts are needed, follow the Shared Contracts Protocol in CLAUDE.md.
9. **Claim ownership.** Self-assign the pitch issue:
   `gh issue edit <pitch-number> --add-assignee @me`
10. **Initial commit.** Stage the `Cargo.toml` version change and any new spec/log files. Commit:

    ```
    chore(<feature>): set up feature branch

    Create worktree, set pre-release version, scaffold specs.
    Part of <release>.
    ```

11. **Smoke test.** Verify the branch builds and launches before writing feature code:
    ```bash
    cargo build --features dev
    cargo run --features dev
    ```
    The app should launch and display the editor window. Close it manually. If it crashes, **stop
    and investigate** — do not proceed with feature work on a broken baseline. Common causes: stale
    build artifacts from a shared `target/` directory (run `cargo clean -p hexorder`), or an
    accidental `cargo update` that changed transitive dependencies.

After this checklist, proceed to the Development Workflow in CLAUDE.md.

---

## Integration Branch Setup Checklist

Run these steps when creating the integration branch for a multi-pitch cycle. The **cycle agent**
runs this checklist. Pitch agents do not create the integration branch — they verify it exists
before creating their feature branches.

1. **Check remote.** Does the integration branch already exist on the remote?
    ```bash
    git ls-remote --heads origin <version>
    ```
    If it does, fetch and track it locally, then skip to step 9:
    ```bash
    git fetch origin <version>
    git branch <version> origin/<version>
    ```
2. **Check local.** Does the integration branch exist locally?
    ```bash
    git branch --list <version>
    ```
    If it does, push it to the remote and skip to step 9:
    ```bash
    git push -u origin <version>
    ```
3. **Sync main.** Ensure local `main` is up to date with `origin/main`:
    ```bash
    git fetch origin main
    git diff main origin/main --stat
    ```
    If they differ, fast-forward local main:
    ```bash
    git checkout main
    git merge --ff-only origin/main
    ```
    If fast-forward fails (local main has diverged), **stop and resolve manually** — do not
    force-push or rebase main.
4. **Check for uncommitted changes.** If you are on `main` and there are uncommitted changes:
    ```bash
    git status --short
    ```
    If dirty, **stop** — commit or stash changes before creating the integration branch. The
    integration branch must fork from a clean, synced main.
5. **Create the branch.** From the synced, clean main:
    ```bash
    git branch <version> main
    ```
6. **Push to remote.**
    ```bash
    git push -u origin <version>
    ```
7. **Create worktree.** The integration branch gets a worktree just like feature branches. The main
   working tree must always stay on `main`.
    ```bash
    git worktree add .worktrees/<version> <version>
    cd .worktrees/<version>
    ```
8. **Install hooks and trust.** Same as Feature Branch Setup steps 3-4:
    ```bash
    lefthook install
    mise trust
    cp ../../.claude/settings.local.json .claude/settings.local.json
    ```
9. **Record in milestone.** Append `| Integration branch: <version>` to the milestone description if
   not already present.
10. **Report.** If a cycle tracking issue exists, check off the corresponding items and post a
    comment confirming the integration branch is ready:
    ```bash
    gh issue comment <tracking-number> --body "Integration branch \`<version>\` created from main ($(git rev-parse --short main)). Worktree at \`.worktrees/<version>\`. Ready for feature branches."
    ```

---

## Feature Branch Sync

When the cycle agent integrates other pitches into the integration branch, remaining feature
branches fall behind. Pitch agents sync their feature branches to stay current.

### When to sync

- Before starting a new scope (to build on the latest integrated state)
- After another pitch is integrated (the tracking issue comment thread announces integrations)
- Before declaring "Ready for integration" (to minimize conflicts during rebase)

### How to sync

Rebase the feature branch onto the integration branch:

```bash
git fetch origin <version>
git rebase origin/<version>
```

If conflicts arise during the rebase, resolve them commit-by-commit. After resolving all conflicts,
run `cargo build && cargo test` before continuing the rebase.

### Force-push after rebase

Rebasing rewrites history. Push with `--force-with-lease` to update the remote safely:

```bash
git push --force-with-lease origin <release>-<feature>
```

This is safe because each feature branch is owned by a single pitch agent — no other session pulls
from it.

---

## Feature Branch Teardown Checklist

Run these steps after a feature branch has been merged to `main` and the merge tag is verified.

1. **Verify merge.** Confirm the merge commit and tag exist on `main`:
    ```bash
    git log --oneline -5 main
    git tag -l 'v0.*'
    ```
2. **Remove worktree.**
    ```bash
    git worktree remove .worktrees/<release>-<feature>
    ```
3. **Delete local branch.**
    ```bash
    git branch -d <release>-<feature>
    ```
4. **Delete remote branch.**
    ```bash
    git push origin --delete <release>-<feature>
    ```
5. **Update ownership.** The pitch issue is closed automatically when the merge commit reaches
   `main` (if the commit uses a closing keyword like `fixes #N`). If not, close manually:
   `gh issue close <pitch-number> --reason completed`
6. **Verify clean state.** Run `git worktree list` and confirm only the main worktree remains (plus
   any other active plugin worktrees).

---

## Commits

### Commit early and often

- Commit whenever you reach a coherent working state — a system compiles, a test passes, a contract
  is defined
- Small, frequent commits are preferred over large, infrequent ones
- **Every commit must compile.** `cargo check` must succeed before committing. This is enforced by
  the `pre-commit` hook and keeps history bisect-friendly — `git bisect` can binary-search any
  regression across the commit history
- Incomplete work is fine on feature branches as long as it compiles; the merge to `main` is what
  matters for test quality
- Specs, contracts, and code for the same change travel together in the same commit

### Checkpoint commits

Before attempting a risky change (large refactor, contract modification, deleting significant code),
commit the current known-good state as a checkpoint:

```
chore(<feature>): checkpoint before <description>
```

Examples:

```
chore(unit): checkpoint before movement system refactor
chore(contracts): checkpoint before adding unit stacking types
```

This gives a clean rollback point. If the risky change fails or goes wrong:

```bash
git reset --hard HEAD~<n>   # roll back to the checkpoint
```

Checkpoint commits are normal commits — they travel with the branch and get merged. They're cheap
insurance against lost work, especially for agents that can't interactively undo edits.

### Commit message format

Follow **conventional commit** practices. Every commit message **must** match this structure:

```
<type>(<scope>): <summary>

<optional body>
```

**Types** — use exactly one of:

| Type       | When to use                                                   |
| ---------- | ------------------------------------------------------------- |
| `feat`     | New functionality (system, component, plugin, UI element)     |
| `fix`      | Bug fix                                                       |
| `refactor` | Code restructuring with no behavior change                    |
| `test`     | Adding or updating tests only                                 |
| `docs`     | Documentation, specs, logs, guides                            |
| `chore`    | Build config, version bumps, tooling, cleanup                 |
| `style`    | Formatting, whitespace, brand/theme changes (no logic change) |

**Scope** — use exactly one of:

| Scope       | When to use                                                                                                   |
| ----------- | ------------------------------------------------------------------------------------------------------------- |
| Plugin name | Work within a single plugin (`unit`, `cell`, `hex_grid`, `camera`, `game_system`, `editor_ui`, `persistence`) |
| `contracts` | Shared type definitions in `src/contracts/` or `docs/contracts/`                                              |
| `project`   | Cross-cutting changes (CLAUDE.md, coordination, git guide, build config)                                      |

**Subject line rules**:

- Imperative mood ("add", not "added" or "adds")
- Lowercase (no capital first letter)
- No trailing period
- Maximum 72 characters total (including type and scope)

**Body rules** (when present):

- Separated from subject by one blank line
- Wrap at 72 characters
- Explain _why_, not _what_ — the diff shows what changed
- Reference the release when relevant: "Part of 0.3.0"

**Examples**:

```
feat(unit): add unit placement and movement systems

Implements UnitPlugin with spawn, move, delete, and visual sync systems.
Adds 9 unit tests and 4 integration tests. Part of 0.3.0.
```

```
docs(contracts): add unit type contract spec

Defines UnitType, UnitData, UnitInstance, and UnitPlacedEvent shared
types for 0.3.0. Matches src/contracts/game_system.rs additions.
```

```
fix(editor_ui): prevent panel click from painting cells

Guard cell painting systems with egui_wants_any_pointer_input check.
```

```
chore(project): bump version to 0.3.0
```

---

## Pre-Commit Checklist

**Every commit** on a feature branch must pass this checklist. Steps 1-3 are **enforced
automatically by lefthook** (see Setup above). Step 4 requires manual verification.

1. **Files staged?** Run `git status`. Confirm only intended files are staged. No secrets (`.env`,
   credentials). No files belonging to another plugin. _(Secrets check enforced by `pre-commit`
   hook.)_
2. **Compiles?** Run `cargo check`. Must succeed. _(Enforced by `pre-commit` hook.)_
3. **Message format?** Confirm the commit message matches `<type>(<scope>): <summary>` with valid
   type and scope from the tables above. Subject line is imperative, lowercase, no period, max 72
   characters. _(Enforced by `commit-msg` hook.)_
4. **Specs with code?** If the commit includes changes to `src/contracts/`, confirm matching
   `docs/contracts/` changes are also staged. If the commit includes a new system or component,
   confirm `docs/plugins/<name>/spec.md` is up to date. _(Manual — not automated.)_

If any check fails (hook rejection or manual verification), fix the issue before committing.

---

## Merging

### Pitch Merge (feature branch → integration branch)

When a pitch finishes its scope, the **cycle agent** integrates it into the integration branch using
rebase + fast-forward to maintain linear commit history. Pitch agents do not merge their own
branches — they declare "Ready for integration" on their lifecycle checklist.

All merge operations use **worktrees** — never `git checkout` on the main working tree. The main
working tree must always stay on `main`.

1. **Quality gate?** Run `mise check:audit` on the feature branch. All checks must pass.
2. **Spec criteria met?** Every success criterion in `docs/plugins/<name>/spec.md` is satisfied.
3. **Deferred items captured?** Check spec and log for deferred items. Every item must have a
   corresponding GitHub Issue. Scan source code for TODO/FIXME comments — these must have
   corresponding issues or be removed.
4. **Rebase onto integration branch.** From the feature branch worktree:
    ```bash
    cd .worktrees/<release>-<feature>
    git fetch origin <version>
    git rebase origin/<version>
    ```
    If conflicts arise, resolve them commit-by-commit. After resolving, run `mise check:audit`.
5. **Fast-forward merge.** From the integration branch worktree:
    ```bash
    cd .worktrees/<version>
    git merge --ff-only <release>-<feature>
    ```
6. **Re-test after merge?** Run `mise check:audit` on the integration branch. All checks must pass.
7. **Push integration branch.** Push the updated integration branch to the remote:
    ```bash
    git push origin <version>
    ```
8. **Update lifecycle.** Check off "Merged to integration branch" on the pitch issue's Lifecycle
   section. Post a status comment on the cycle tracking issue.

### Ship Merge (integration branch → main)

After all pitches merge into the integration branch and UAT passes, merge to `main`. This happens
once per cycle. All operations use **worktrees** — the main working tree stays on `main`.

1. **All pitches merged?** Check that no open pitch issues remain for the milestone:
   `gh issue list --milestone "<milestone>" --label "type:pitch" --state open`
2. **UAT passed?** Walk through the UAT checklist (max 5 items per pitch). Record results as a
   comment on each pitch issue.
3. **Ship gate audit.** Run `mise check:audit` on the integration branch worktree plus the manual
   checks from the Ship Gate in CLAUDE.md. If any check fails, fix and re-run.
4. **Remove plan documents.** Delete transient build-phase artifacts from `docs/plans/` that were
   created during this cycle's kickoff and orientation. These documents guided implementation but
   the canonical record now lives in plugin specs, plugin logs, and pitch issue comments. If any
   code changes result from this cleanup (e.g., references to plan files), re-run `mise check:audit`
   before proceeding.
5. **Version bumped?** Determine the correct next version (see Version Lookup Table below). Update
   `Cargo.toml`. Strip the pre-release suffix.
6. **Rebase onto main.** From the integration branch worktree:
    ```bash
    cd .worktrees/<version>
    git rebase main
    ```
    If conflicts arise, resolve and re-test with `mise check:audit`.
7. **Merge.** From the main working tree (which is on `main`):
    ```bash
    cd <project-root>
    git merge --ff-only <version>
    ```
8. **Generate changelog.** Run `mise changelog:generate`.
9. **Verify changelog.** Read `CHANGELOG.md` and confirm the first `##` entry shows the release
   version and date (e.g., `## [0.10.0] — 2026-02-19`), not `## [Unreleased]`. If `[Unreleased]`
   appears, the release tag was not recognized — check that the tag exists and matches the
   `tag_pattern` in `cliff.toml`. Fix and regenerate before proceeding.
10. **Version commit.** Stage `Cargo.toml` and `CHANGELOG.md`, commit:
    `chore(project): bump version to <version>`.
11. **Tag.** Create annotated tag: `git tag -a v<version> -m "<release>: <title>"`.
12. **Verify.** Run `git log --oneline -5` and `git tag -l` to confirm the merge, commit, and tag.
13. **Push tag.** `git push origin main v<version>`.
14. **Create GitHub Release.**
    `gh release create v<version> --title "<release>: <title>" --notes-file CHANGELOG.md`
15. **Issue cleanup.** Close all GitHub Issues completed in this cycle:
    `gh issue list --milestone "<milestone>" --state open` — close each with
    `gh issue close <number> --reason completed`.
16. **Teardown worktrees.** Remove all cycle worktrees (integration + feature branches). Run from
    the main working tree:
    ```bash
    git worktree remove .worktrees/<version>
    git worktree remove .worktrees/<version>-<feature-1>
    git worktree remove .worktrees/<version>-<feature-2>
    git branch -d <version> <version>-<feature-1> <version>-<feature-2>
    ```
    Verify with `git worktree list` — only the main working tree should remain.
17. **Delete remote branches.** Remove the integration branch and all feature branches that were
    merged during this cycle from the remote:
    ```bash
    git push origin --delete <version> <version>-<feature-1> <version>-<feature-2>
    ```
    Verify with `git branch -r` — no `origin/<version>` or `origin/<version>-<feature>` refs should
    remain.
18. **Run cool-down protocol.** Run `/hex-cooldown` to start the retrospective, shaping, and betting
    for the next cycle.

### Solo-Pitch Merge (feature branch → main directly)

For cycles with only one pitch, the integration branch is optional. Use this simplified flow:

1. **Quality gate?** Run `mise check:audit`. All checks must pass.
2. **Spec criteria met?** Every success criterion satisfied.
3. **Deferred items captured?** All deferred items have GitHub Issues.
4. **Remove plan documents.** Same as Ship Merge step 4.
5. **Rebased?** `git rebase main`. Re-test with `mise check:audit`.
6. **Merge.** `git merge --ff-only <branch>`.
7. **Generate changelog.** `mise changelog:generate`.
8. **Verify changelog.** Same as Ship Merge step 9 — confirm no `[Unreleased]` header.
9. **Version commit + tag + push.** Same as Ship Merge steps 10-14.
10. **Issue cleanup + teardown + cool-down.** Same as Ship Merge steps 15-18.

### Conflict Resolution

When rebasing onto `main` produces merge conflicts, resolve them by file type:

**`src/contracts/` (shared types)**

1. Accept the version already on `main` — it was merged first and other plugins may depend on it.
2. Re-apply your additions on top. Do not remove or rename types that the other branch introduced.
3. Update your plugin's code to work with the merged contract state.
4. If the conflict is structural (incompatible type changes), stop the rebase (`git rebase --abort`)
   and create a GitHub Issue with the `area:contracts` label to coordinate the change before
   proceeding.

**`CHANGELOG.md`**

1. Accept the `main` version (which includes the other branch's entry).
2. Add your entry above it (newest first).

**`Cargo.toml` (version field)**

1. Accept the `main` version.
2. Your version bump happens in Pre-Merge Checklist step 10, after the rebase — so the conflict here
   is between your pre-release suffix and the merged release version. Take the merged version;
   you'll set the final version in step 10.

**`src/<plugin>/` (your own plugin code)**

1. If `main` changed your plugin's files (unlikely in the worktree model), investigate why. Another
   session should not be modifying your plugin.
2. If the conflict is in shared infrastructure (e.g., `main.rs` plugin registration), accept
   `main`'s additions and add yours alongside.

**General rules:**

- Never silently drop the other branch's changes to resolve a conflict.
- After resolving all conflicts, run `cargo build` and `cargo test` before continuing the rebase.
- If a conflict is too complex to resolve confidently, abort the rebase and coordinate with the
  other session.

### Rollback

If a merge to `main` introduces a regression:

1. **Revert the merge commit**: `git revert -m 1 <merge-sha>`
2. **Tag the revert**: `git tag -a v<version>.1 -m "Revert: <reason>"`
3. **Push**: `git push origin main v<version>.1`
4. **Reopen the feature branch** to fix the issue
5. **Re-merge** following the normal Pre-Merge Checklist once the fix is verified

Do not delete or force-push tags. The revert creates a clean history record.

### Breaking Changes

For commits that introduce breaking changes, add a `BREAKING CHANGE:` footer to the commit body:

```
feat(game_system): replace PropertyValue with TypedValue

BREAKING CHANGE: PropertyValue enum variants renamed. All save files
using the old format must be migrated.
```

git-cliff renders these in a separate "Breaking Changes" section in the changelog. Include migration
steps in the commit body or a linked document.

---

## Versioning

Hexorder follows **semantic versioning** (`MAJOR.MINOR.PATCH`) with releases driving minor versions.

| Version           | Meaning                                                          |
| ----------------- | ---------------------------------------------------------------- |
| `0.x.0`           | Release (0.1.0, 0.2.0, etc.)                                     |
| `0.x.y`           | Patch within a release (bug fixes, small additions post-release) |
| `0.x.0-<feature>` | Pre-release on a feature branch (e.g., `0.4.0-movement-rules`)   |
| `1.0.0`           | First production-quality release (future)                        |

The `0.x` series signals pre-release. Breaking changes are expected between releases.

### Pre-release versions on feature branches

While working on a feature branch, `Cargo.toml` carries a **pre-release suffix**:

```
0.4.0-movement-rules
```

- The suffix is the `<feature>` portion of the branch name
- This is valid semver — Cargo and tooling recognize it as a pre-release
- The suffix identifies which branch produced a given build
- The suffix is **stripped at merge time** when the version is set to its final `0.x.0` or `0.x.y`
  form in the Pre-Merge Checklist

### Version Lookup Table

This table is the **single source of truth** for version assignment. Update it when a new release
begins.

| Release | Version  | Tag       | Title                    |
| ------- | -------- | --------- | ------------------------ |
| 0.1.0   | `0.1.0`  | `v0.1.0`  | The World Exists         |
| 0.2.0   | `0.2.0`  | `v0.2.0`  | The World Has Properties |
| 0.3.0   | `0.3.0`  | `v0.3.0`  | Things Live in the World |
| 0.4.0   | `0.4.0`  | `v0.4.0`  | Rules Shape the World    |
| 0.5.0   | `0.5.0`  | `v0.5.0`  | The World Remembers      |
| 0.6.0   | `0.6.0`  | `v0.6.0`  | The World Has Identity   |
| 0.7.0   | `0.7.0`  | `v0.7.0`  | The World Has Structure  |
| 0.8.0   | `0.8.0`  | `v0.8.0`  | Process Reform           |
| 0.9.0   | `0.9.0`  | `v0.9.0`  | The World Comes Alive    |
| 0.10.0  | `0.10.0` | `v0.10.0` | Sharpen the Tools        |
| 0.11.0  | `0.11.0` | `v0.11.0` | Sharpen & Rearchitect    |
| 0.12.0  | `0.12.0` | `v0.12.0` | Deliver & Polish         |

To determine the next version for a merge:

1. Look up the current release in the table above.
2. If this is the first or only merge for the release, use `0.x.0`.
3. If a `0.x.0` tag already exists for this release, increment the patch: `0.x.1`, `0.x.2`, etc.

---

## Tags

Every merge to `main` that bumps the version gets an **annotated** tag:

```bash
git tag -a v0.3.0 -m "0.3.0: Things Live in the World"
```

Tag message format: `<release>: <title>` for releases, or `<release>: <brief description>` for
patches.

---

## Changelog Format

`CHANGELOG.md` is **auto-generated** by [git-cliff](https://git-cliff.org/) from conventional commit
messages. Configuration lives in `cliff.toml` at the project root.

### Generation

```bash
mise changelog:generate              # regenerate full changelog from all tags
mise changelog                       # preview unreleased changes (stdout)
git cliff --latest --output CHANGELOG.md # regenerate only the latest version
```

The generated format follows [Keep a Changelog](https://keepachangelog.com/):

```markdown
## [0.4.0] — 2026-02-15

### Added

- add unit placement and movement systems (unit)
- add unit type contract spec (contracts)

### Fixed

- prevent panel click from painting cells (editor_ui)

### Changed

- bump version to 0.4.0 (project)
```

### How commit messages map to changelog entries

| Commit type | Changelog group |
| ----------- | --------------- |
| `feat`      | Added           |
| `test`      | Added           |
| `docs`      | Added           |
| `fix`       | Fixed           |
| `refactor`  | Changed         |
| `style`     | Changed         |
| `chore`     | Changed         |

The commit scope becomes the parenthetical at the end of each entry.

### Manual edits

After generating, review the output. If a commit message was unclear or needs correction, edit
`CHANGELOG.md` directly. Prefer fixing the commit message convention going forward rather than
habitually hand-editing.

### Edge cases

**Malformed commits**: If a commit doesn't match `type(scope): summary`, git-cliff will skip it. The
entry won't appear in the generated changelog. Fix by amending the commit message (if not yet
pushed) or noting the omission in a manual edit after generation.

**Regeneration safety**: `mise changelog:generate` regenerates the full changelog from all tags. It
is safe to run repeatedly — git-cliff reads from git history, not from the existing `CHANGELOG.md`.
Any manual edits to `CHANGELOG.md` will be overwritten on the next regeneration.

**Breaking changes**: Commit messages with a `BREAKING CHANGE:` footer are rendered in a separate
section (see Breaking changes under Commits above). Always include migration steps in the commit
body.

### Rules

- Never hand-write changelog entries from scratch — always generate first, then review
- The changelog is regenerated on every ship merge to `main` (Ship Merge step 7)
- Versions are listed in reverse chronological order (newest first)

---

## Design Document Lifecycle

Design documents live in `docs/plans/` and are created during the orientation phase of a build
cycle. They capture implementation plans, architecture decisions, and design rationale.

### Lifecycle

| Phase                     | Status     | Source of Truth                                               |
| ------------------------- | ---------- | ------------------------------------------------------------- |
| **During implementation** | Active     | The design doc is the reference for approach and decisions    |
| **After implementation**  | Historical | The code, specs, contracts, and plugin logs are authoritative |

### After Implementation

When a pitch ships, the design doc becomes historical. Before marking it as such:

1. **Propagate key decisions** into permanent docs:
    - Architecture decisions → `docs/architecture.md` or plugin spec
    - Contract decisions → `docs/contracts/<name>.md`
    - Process learnings → plugin log or relevant guide
    - Deferred items → GitHub Issues
2. **Mark the design doc as historical** by adding a header at the top:
    ```markdown
    > **Historical** — Implemented in v0.x.0. The code, plugin specs, and contracts are now
    > authoritative. This document is preserved for context on why decisions were made.
    ```
3. Do not delete design docs — they serve as a record of _why_ decisions were made, which the
   permanent docs may not capture.

### Naming Convention

Design docs follow the pattern: `<date>-<feature-name>.md` or `<date>-<feature-name>-design.md` for
architecture-focused docs.

---

## Session Handoff Protocol

When a new Claude Code session picks up work on an existing feature branch, run these steps before
doing anything else.

**Quick start**: Run `mise handoff` to get a snapshot of worktrees, branch, status, commits, and
changed files. Then continue with the detailed steps below for anything that needs attention.

1. **Check for orphaned worktrees.** Run `git worktree list`. If there are worktrees from a prior
   session that is no longer active:
    - `cd` into the orphaned worktree and run `git status`.
    - If there are uncommitted changes, evaluate them: commit coherent work with a checkpoint commit
      (`chore(<feature>): recover uncommitted work from prior session`), or discard broken fragments
      with `git checkout -- .`.
    - If the worktree is for a different plugin than yours, leave it alone — another session may own
      it.
    - If the worktree is for your plugin, continue working in it. If you need a fresh worktree,
      clean up the orphan first: `git worktree remove <path>`.
2. **Identify the branch.** Run `git branch --show-current` to confirm you're on the correct feature
   branch.
3. **Check for uncommitted work.** Run `git status`. If there are unstaged or staged changes from a
   prior session, review them. Commit coherent work; discard broken fragments.
4. **Review branch history.** Run `git log --oneline main..HEAD` to see what the previous session(s)
   committed on this branch. Use the conventional commit format to reconstruct context:
    - **Group by type** to understand what was done: `feat` = new functionality, `fix` = bug fixes,
      `refactor` = restructuring, `test` = test additions, `docs` = spec/doc updates, `chore` =
      setup/config.
    - **Group by scope** to understand what was touched: each scope maps to a plugin module or
      `contracts`/`project`.
    - **Read commit bodies** (run `git log main..HEAD` without `--oneline`) for rationale and
      decisions — these serve as lightweight decision records between log entries.
    - **Identify the last checkpoint commit** (if any) — this marks the last known-good state the
      prior session saved before a risky change.
5. **Load context from diff.** Run `git diff main..HEAD --stat` for a file-level summary, then
   `git diff main..HEAD` for the full delta. This is the fastest way to understand what this branch
   has changed relative to mainline.
6. **Read the spec and log.** Open `docs/plugins/<name>/spec.md` and `docs/plugins/<name>/log.md`.
   The log records decisions, blockers, and test results from prior sessions.
7. **Check coordination.** Check for contract changes or blockers that appeared since the last
   session: `gh issue list --label "area:contracts" --state open` and
   `gh issue list --label "status:blocked" --state open`
8. **Resume the Development Workflow.** Pick up from the appropriate step in CLAUDE.md's Development
   Workflow based on what the prior session completed.

This protocol ensures no prior work is lost or duplicated, and the new session starts with full
context from git history + specs.

---

## Agent-Specific Rules

When a Claude Code session needs to commit:

1. **Read this guide first** — follow the message format and conventions
2. **Run the Pre-Commit Checklist** (above) for every commit
3. **Run the Pre-Merge Checklist** (above) for every merge to `main`
4. **Never force-push to `main`**
5. **Never commit secrets** (`.env`, credentials, API keys)
6. **Commit specs and code together** — a contract spec and its Rust implementation belong in the
   same commit
7. **Use the worktree for your plugin** — don't commit another plugin's work
8. **When in doubt, commit** — it's easier to squash later than to recover lost work
9. **Multi-terminal coordination**: each session works in its own worktree on its own branch
10. **Integration branch**: feature branches merge to the integration branch via Pitch Merge; only
    Ship Merge touches `main`
11. **Issue references**: reference GitHub Issue numbers in commits when closing or addressing
    tracked items (e.g., `fixes #42`, `ref #42`)
12. **Deferred items**: create GitHub Issues for deferred items before merge
13. **Duplicate check**: search existing issues before creating:
    `gh issue list --search "<keywords>" --state all`
