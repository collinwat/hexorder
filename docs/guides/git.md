# Hexorder — Git Guide

## Strategy

Hexorder uses **trunk-based development with worktrees**, operating within Shape Up build cycles.

The `main` branch is the mainline — it must always compile, pass tests, and represent a shippable
state. Feature work happens on short-lived branches via git worktrees, merged back to `main` when
the cycle's scope is complete.

Build cycles have fixed time and variable scope. Branches are created within a cycle to implement
shaped pitches. At the end of the cycle, completed work ships.

- Small, frequent commits on feature branches
- Deliberate merges to mainline with version bump and changelog
- Every merge tagged with an annotated version tag

---

## Setup

Project tooling is managed by [mise](https://mise.jdx.dev/). Git hooks are managed by
[lefthook](https://github.com/evilmartians/lefthook). Changelogs are generated by
[git-cliff](https://git-cliff.org/).

### First-time setup

```bash
mise setup      # installs tools, configures git-lfs and hooks
```

Or manually:

```bash
mise install        # installs lefthook, git-lfs, and any other project tools
git lfs install     # configures git-lfs for this user (once per machine)
lefthook install    # installs git hooks into .git/hooks/
```

### What the hooks enforce

| Hook         | What it checks                                                                                            |
| ------------ | --------------------------------------------------------------------------------------------------------- |
| `commit-msg` | Message matches `<type>(<scope>): <summary>` with valid types and scopes. Subject line max 72 characters. |
| `pre-commit` | No secrets staged (`.env`, credentials, keys). Code compiles (`cargo check`). Formatting is correct.      |

These hooks are the automated enforcement of the Pre-Commit Checklist. If a hook rejects your
commit, fix the issue — do not bypass with `--no-verify`.

### Git LFS

Binary assets (images, fonts, audio, 3D models) are tracked by Git LFS to prevent repo bloat.
Tracked patterns are defined in `.gitattributes` at the project root.

When adding a **new binary file type** to the project, add a corresponding LFS tracking rule to
`.gitattributes` before committing the files.

### Configuration

- `mise.toml` — declares project tools (lefthook, git-lfs, git-cliff)
- `lefthook.yml` — defines hook commands and validation rules
- `cliff.toml` — defines changelog generation template and commit parsers
- `.gitattributes` — defines Git LFS tracking patterns for binary assets

When adding a new plugin scope (e.g., a new plugin module), update the scope regex in
`lefthook.yml`'s `commit-msg` hook to include it.

---

## Branching

### Mainline: `main`

- Always builds (`cargo build` clean)
- Always passes tests (`cargo test`) and lint (`cargo clippy -- -D warnings`)
- Every merge to `main` is tagged with a release version
- Direct commits to `main` are limited to project-level config and documentation (e.g., CLAUDE.md,
  docs/, docs/ process files)

### Feature branches

- One branch per plugin or release task
- Use **git worktrees** (under `.worktrees/`) so each plugin gets its own working directory,
  allowing parallel development without stashing or switching
- Keep branches short-lived — merge when the plugin passes its spec criteria and tests
- Rebase onto `main` before merging to keep history linear

### Branch naming

Branch names **must** follow this pattern:

```
<release>/<feature>
```

- `<release>` is the target release version: `0.1.0`, `0.2.0`, `0.3.0`, etc.
- `<feature>` is the plugin name as it appears in `docs/coordination.md`, using hyphens for
  multi-word names

**Valid**: `0.3.0/unit`, `0.3.0/editor-ui`, `0.4.0/movement-rules` **Invalid**: `feature/unit`,
`unit-placement`, `m3_unit`, `0.3.0/Unit`

For non-plugin work (docs, process, tooling), use:

```
<release>/chore-<description>
```

**Valid**: `0.3.0/chore-git-guide`, `0.4.0/chore-ci-setup`

---

## Feature Branch Setup Checklist

Run these steps in order when starting work on a new plugin. No steps are optional.

1. **Branch name.** Determine the branch name: `<release>/<feature>` (e.g., `0.4.0/movement-rules`).
   Verify it follows the naming rules above.
2. **Create branch and worktree.** Worktrees live under `.worktrees/` in the project root. The
   directory name is the branch name with `/` replaced by `-`.
    ```bash
    git branch 0.4.0/movement-rules
    git worktree add .worktrees/0.4.0-movement-rules 0.4.0/movement-rules
    cd .worktrees/0.4.0-movement-rules
    ```
3. **Install hooks in worktree.** Run `lefthook install` in the new worktree directory. Worktrees
   have their own git hooks and need lefthook installed separately.
4. **Set pre-release version.** Edit `Cargo.toml` and append a pre-release suffix to the version:
    ```toml
    version = "0.4.0-movement-rules"
    ```
    The suffix is the `<feature>` portion of the branch name. This identifies builds from this
    branch. The suffix is stripped at merge time when the final version is set.
5. **Spec scaffolding.** Verify the plugin has spec and log files. If they don't exist, create them
   from the templates:
    ```
    docs/plugins/<plugin>/spec.md   ← copy from docs/guides/plugin.md
    docs/plugins/<plugin>/log.md    ← copy from docs/guides/plugin.md
    ```
    If the files already exist, read them to understand prior decisions.
6. **Contract check.** Read `docs/contracts/` for any shared types the plugin depends on or
   introduces. If new contracts are needed, follow the Shared Contracts Protocol in CLAUDE.md.
7. **Claim ownership.** Update `docs/coordination.md` → Active Plugins table: set Owner to your
   session identifier and Status to `in-progress`.
8. **Initial commit.** Stage the `Cargo.toml` version change, any new spec/log files, and the
   coordination.md update. Commit:

    ```
    chore(<feature>): set up feature branch

    Create worktree, set pre-release version, scaffold specs.
    Part of <release>.
    ```

After this checklist, proceed to the Development Workflow in CLAUDE.md.

---

## Feature Branch Teardown Checklist

Run these steps after a feature branch has been merged to `main` and the merge tag is verified.

1. **Verify merge.** Confirm the merge commit and tag exist on `main`:
    ```bash
    git log --oneline -5 main
    git tag -l 'v0.*'
    ```
2. **Remove worktree.**
    ```bash
    git worktree remove .worktrees/<release>-<feature>
    ```
3. **Delete branch.**
    ```bash
    git branch -d <release>/<feature>
    ```
4. **Update ownership.** In `docs/coordination.md` → Active Plugins table, set Status to `complete`
   and clear Owner.
5. **Release merge lock.** If not already done in the Pre-Merge Checklist, confirm your Merge Lock
   row status is `done`.
6. **Verify clean state.** Run `git worktree list` and confirm only the main worktree remains (plus
   any other active plugin worktrees).

---

## Commits

### Commit early and often

- Commit whenever you reach a coherent working state — a system compiles, a test passes, a contract
  is defined
- Small, frequent commits are preferred over large, infrequent ones
- **Every commit must compile.** `cargo check` must succeed before committing. This is enforced by
  the `pre-commit` hook and keeps history bisect-friendly — `git bisect` can binary-search any
  regression across the commit history
- Incomplete work is fine on feature branches as long as it compiles; the merge to `main` is what
  matters for test quality
- Specs, contracts, and code for the same change travel together in the same commit

### Checkpoint commits

Before attempting a risky change (large refactor, contract modification, deleting significant code),
commit the current known-good state as a checkpoint:

```
chore(<feature>): checkpoint before <description>
```

Examples:

```
chore(unit): checkpoint before movement system refactor
chore(contracts): checkpoint before adding unit stacking types
```

This gives a clean rollback point. If the risky change fails or goes wrong:

```bash
git reset --hard HEAD~<n>   # roll back to the checkpoint
```

Checkpoint commits are normal commits — they travel with the branch and get merged. They're cheap
insurance against lost work, especially for agents that can't interactively undo edits.

### Commit message format

Follow **conventional commit** practices. Every commit message **must** match this structure:

```
<type>(<scope>): <summary>

<optional body>
```

**Types** — use exactly one of:

| Type       | When to use                                                   |
| ---------- | ------------------------------------------------------------- |
| `feat`     | New functionality (system, component, plugin, UI element)     |
| `fix`      | Bug fix                                                       |
| `refactor` | Code restructuring with no behavior change                    |
| `test`     | Adding or updating tests only                                 |
| `docs`     | Documentation, specs, logs, guides                            |
| `chore`    | Build config, version bumps, tooling, cleanup                 |
| `style`    | Formatting, whitespace, brand/theme changes (no logic change) |

**Scope** — use exactly one of:

| Scope       | When to use                                                                                    |
| ----------- | ---------------------------------------------------------------------------------------------- |
| Plugin name | Work within a single plugin (`unit`, `cell`, `hex_grid`, `camera`, `game_system`, `editor_ui`) |
| `contracts` | Shared type definitions in `src/contracts/` or `docs/contracts/`                               |
| `project`   | Cross-cutting changes (CLAUDE.md, coordination, git guide, build config)                       |

**Subject line rules**:

- Imperative mood ("add", not "added" or "adds")
- Lowercase (no capital first letter)
- No trailing period
- Maximum 72 characters total (including type and scope)

**Body rules** (when present):

- Separated from subject by one blank line
- Wrap at 72 characters
- Explain _why_, not _what_ — the diff shows what changed
- Reference the release when relevant: "Part of 0.3.0"

**Examples**:

```
feat(unit): add unit placement and movement systems

Implements UnitPlugin with spawn, move, delete, and visual sync systems.
Adds 9 unit tests and 4 integration tests. Part of 0.3.0.
```

```
docs(contracts): add unit type contract spec

Defines UnitType, UnitData, UnitInstance, and UnitPlacedEvent shared
types for 0.3.0. Matches src/contracts/game_system.rs additions.
```

```
fix(editor_ui): prevent panel click from painting cells

Guard cell painting systems with egui_wants_any_pointer_input check.
```

```
chore(project): bump version to 0.3.0
```

---

## Pre-Commit Checklist

**Every commit** on a feature branch must pass this checklist. Steps 1-3 are **enforced
automatically by lefthook** (see Setup above). Step 4 requires manual verification.

1. **Files staged?** Run `git status`. Confirm only intended files are staged. No secrets (`.env`,
   credentials). No files belonging to another plugin. _(Secrets check enforced by `pre-commit`
   hook.)_
2. **Compiles?** Run `cargo check`. Must succeed. _(Enforced by `pre-commit` hook.)_
3. **Message format?** Confirm the commit message matches `<type>(<scope>): <summary>` with valid
   type and scope from the tables above. Subject line is imperative, lowercase, no period, max 72
   characters. _(Enforced by `commit-msg` hook.)_
4. **Specs with code?** If the commit includes changes to `src/contracts/`, confirm matching
   `docs/contracts/` changes are also staged. If the commit includes a new system or component,
   confirm `docs/plugins/<name>/spec.md` is up to date. _(Manual — not automated.)_

If any check fails (hook rejection or manual verification), fix the issue before committing.

---

## Merging to Mainline

Merging a feature branch to `main` is a deliberate act. Only one merge may be in progress at a time,
coordinated through the **Merge Lock** in `docs/coordination.md`.

### Merge Lock Protocol

Before starting a merge, you **must** claim the merge lock:

1. **Check the lock.** Read `docs/coordination.md` → Merge Lock table. If any row has status
   `merging`, **stop and wait**. Do not proceed until the lock is clear.
2. **Claim the lock.** Add a row with your branch, the version you intend to use (determined from
   the Version Lookup Table), your session identifier, and status `merging`.
3. **Proceed with the Pre-Merge Checklist** below.
4. **Release the lock.** After the tag is created and verified, update your row's status to `done`.

If a row has been `merging` for an unreasonable time (e.g., the owning session is no longer active),
investigate before overriding. Do not silently clear another session's lock.

### Pre-Merge Checklist

Every merge to `main` must pass all of these in order:

1. **Merge lock claimed?** Confirm your row is in the Merge Lock table with status `merging` and no
   other row is also `merging`. If you skipped the lock protocol above, stop and go back.
2. **Quality gate?** Run `mise check:audit`. This runs all automated checks: tests, clippy,
   formatting, dependency audit, typos, boundary check, and unwrap check. All must pass.
3. **Scope verified?** Run `git diff main --name-only`. Every changed file must belong to one of
   these categories:
    - Your plugin's module: `src/<plugin>/**`
    - Your plugin's specs: `docs/plugins/<plugin>/**`
    - Contracts your plugin owns or extends: `src/contracts/**`, `docs/contracts/**`
    - Expected shared files: `docs/coordination.md`, `Cargo.toml`, `Cargo.lock`, `main.rs` (plugin
      registration)
    - If any file falls outside these categories, investigate. Either remove the change or justify
      it in the commit body.
4. **Spec criteria met?** Open `docs/plugins/<name>/spec.md`. Every success criterion is satisfied.
5. **Deferred items captured?** Check `docs/plugins/<name>/spec.md` → Deferred Items and
   `docs/plugins/<name>/log.md` → Deferred / Future Work. Every item must have a corresponding
   GitHub Issue (create with `gh issue create --label "status:deferred" --milestone "Backlog"`).
   Also scan source code for TODO/FIXME comments or placeholder text (e.g., "coming soon") — these
   must have corresponding issues or be removed.
6. **Rebased?** Run `git log --oneline main..<branch>`. Confirm the branch is based on current
   `main` tip. If not, rebase first: `git rebase main`. If the rebase produces conflicts, follow the
   Conflict Resolution rules below.
7. **Re-test after rebase?** Run `mise check:audit` again. The rebase may have introduced conflicts
   or breakage not caught earlier. All checks must pass before proceeding.
8. **Version bumped?** Determine the correct next version (see Version Lookup Table below). Update
   the `version` field in `Cargo.toml`. Strip the pre-release suffix (e.g., `0.4.0-unit` becomes
   `0.4.0`).
9. **Merge.** From `main`: `git merge --ff-only <branch>`. The `--ff-only` flag ensures a
   fast-forward (linear history). If it fails, the branch is not rebased — go back to step 6.
10. **Generate changelog.** Run `mise changelog:generate`. Review the generated output to confirm
    it's accurate. Make manual edits only if a commit message was unclear.
11. **Version commit.** Stage `Cargo.toml` and `CHANGELOG.md`, commit:
    `chore(project): bump version to <version>`.
12. **Tag.** Create annotated tag: `git tag -a v<version> -m "<release>: <title>"`.
13. **Verify.** Run `git log --oneline -5` and `git tag -l` to confirm the merge, commit, and tag
    are correct.
14. **Release lock.** Update your Merge Lock row in `docs/coordination.md` to status `done`.
15. **Push tag.** Push the tag to the remote: `git push origin v<version>`.
16. **Create GitHub Release.** Create a release from the tag:
    `gh release create v<version> --title "<release>: <title>" --notes-file CHANGELOG.md`

### Cycle ship merge

When the last scope of a cycle merges, also run these steps:

17. **Ship gate audit.** Run `mise check:audit` plus the manual checks from the Ship Gate in
    CLAUDE.md.
18. **Issue cleanup.** Close all GitHub Issues completed in this cycle:
    `gh issue list --milestone "<milestone>" --state open` — close each with
    `gh issue close <number> --reason completed`. Verify no open issues remain for the release.
19. **Triage new items.** Review issues with `status:triage` label:
    `gh issue list --label "status:triage"`. Assign type/area labels, remove triage label. Review
    open issues older than 2 cycles for staleness.
20. **Run cool-down protocol.** Run `/cooldown` to start the protocol. This includes the
    retrospective, shaping, and betting for the next cycle.

### Conflict Resolution

When rebasing onto `main` produces merge conflicts, resolve them by file type:

**`src/contracts/` (shared types)**

1. Accept the version already on `main` — it was merged first and other plugins may depend on it.
2. Re-apply your additions on top. Do not remove or rename types that the other branch introduced.
3. Update your plugin's code to work with the merged contract state.
4. If the conflict is structural (incompatible type changes), stop the rebase (`git rebase --abort`)
   and coordinate via `docs/coordination.md` Pending Contract Changes before proceeding.

**`docs/coordination.md` (shared coordination state)**

1. Accept the `main` version of the table rows.
2. Re-apply only your row updates (ownership, status).
3. Never overwrite another session's rows or status.

**`CHANGELOG.md`**

1. Accept the `main` version (which includes the other branch's entry).
2. Add your entry above it (newest first).

**`Cargo.toml` (version field)**

1. Accept the `main` version.
2. Your version bump happens in Pre-Merge Checklist step 10, after the rebase — so the conflict here
   is between your pre-release suffix and the merged release version. Take the merged version;
   you'll set the final version in step 10.

**`src/<plugin>/` (your own plugin code)**

1. If `main` changed your plugin's files (unlikely in the worktree model), investigate why. Another
   session should not be modifying your plugin.
2. If the conflict is in shared infrastructure (e.g., `main.rs` plugin registration), accept
   `main`'s additions and add yours alongside.

**General rules:**

- Never silently drop the other branch's changes to resolve a conflict.
- After resolving all conflicts, run `cargo build` and `cargo test` before continuing the rebase.
- If a conflict is too complex to resolve confidently, abort the rebase and coordinate with the
  other session.

### Cross-Branch Integration Testing

When two in-flight feature branches have interdependent contracts or need to be validated together
before either merges to `main`, use a **temporary integration branch**:

1. **Create a throwaway branch** from `main`:
    ```bash
    git branch integration-test main
    git worktree add .worktrees/integration-test integration-test
    cd .worktrees/integration-test
    ```
2. **Merge both feature branches** into it:
    ```bash
    git merge 0.4.0/movement-rules
    git merge 0.4.0/terrain-costs
    ```
3. **Resolve any conflicts** between the two branches (follow the Conflict Resolution rules above).
4. **Run the full test suite**:
    ```bash
    cargo build && cargo test && cargo clippy -- -D warnings
    ```
5. **Evaluate results.** If tests pass, both plugins are compatible — proceed with merging them to
   `main` individually (one at a time, via the normal Pre-Merge Checklist). If tests fail, the
   failing plugin must fix its code on its own branch before retesting.
6. **Discard the integration branch** — it is never merged to `main`:
    ```bash
    git worktree remove .worktrees/integration-test
    git branch -D integration-test
    ```

This branch exists solely for testing. It carries no version bump, no changelog entry, and no tag.
The real merges happen through the normal Pre-Merge Checklist.

### Rollback

If a merge to `main` introduces a regression:

1. **Revert the merge commit**: `git revert -m 1 <merge-sha>`
2. **Tag the revert**: `git tag -a v<version>.1 -m "Revert: <reason>"`
3. **Push**: `git push origin main v<version>.1`
4. **Reopen the feature branch** to fix the issue
5. **Re-merge** following the normal Pre-Merge Checklist once the fix is verified

Do not delete or force-push tags. The revert creates a clean history record.

### Breaking Changes

For commits that introduce breaking changes, add a `BREAKING CHANGE:` footer to the commit body:

```
feat(game_system): replace PropertyValue with TypedValue

BREAKING CHANGE: PropertyValue enum variants renamed. All save files
using the old format must be migrated.
```

git-cliff renders these in a separate "Breaking Changes" section in the changelog. Include migration
steps in the commit body or a linked document.

---

## Versioning

Hexorder follows **semantic versioning** (`MAJOR.MINOR.PATCH`) with releases driving minor versions.

| Version           | Meaning                                                          |
| ----------------- | ---------------------------------------------------------------- |
| `0.x.0`           | Release (0.1.0, 0.2.0, etc.)                                     |
| `0.x.y`           | Patch within a release (bug fixes, small additions post-release) |
| `0.x.0-<feature>` | Pre-release on a feature branch (e.g., `0.4.0-movement-rules`)   |
| `1.0.0`           | First production-quality release (future)                        |

The `0.x` series signals pre-release. Breaking changes are expected between releases.

### Pre-release versions on feature branches

While working on a feature branch, `Cargo.toml` carries a **pre-release suffix**:

```
0.4.0-movement-rules
```

- The suffix is the `<feature>` portion of the branch name
- This is valid semver — Cargo and tooling recognize it as a pre-release
- The suffix identifies which branch produced a given build
- The suffix is **stripped at merge time** when the version is set to its final `0.x.0` or `0.x.y`
  form in the Pre-Merge Checklist

### Version Lookup Table

This table is the **single source of truth** for version assignment. Update it when a new release
begins.

| Release | Version | Tag      | Title                    |
| ------- | ------- | -------- | ------------------------ |
| 0.1.0   | `0.1.0` | `v0.1.0` | The World Exists         |
| 0.2.0   | `0.2.0` | `v0.2.0` | The World Has Properties |
| 0.3.0   | `0.3.0` | `v0.3.0` | Things Live in the World |
| 0.4.0   | `0.4.0` | `v0.4.0` | Rules Shape the World    |
| 0.5.0   | `0.5.0` | `v0.5.0` | The World Remembers      |
| 0.6.0   | `0.6.0` | `v0.6.0` | The World Has Identity   |
| 0.7.0   | `0.7.0` | `v0.7.0` | The World Has Structure  |

To determine the next version for a merge:

1. Look up the current release in the table above.
2. If this is the first or only merge for the release, use `0.x.0`.
3. If a `0.x.0` tag already exists for this release, increment the patch: `0.x.1`, `0.x.2`, etc.

---

## Tags

Every merge to `main` that bumps the version gets an **annotated** tag:

```bash
git tag -a v0.3.0 -m "0.3.0: Things Live in the World"
```

Tag message format: `<release>: <title>` for releases, or `<release>: <brief description>` for
patches.

---

## Changelog Format

`CHANGELOG.md` is **auto-generated** by [git-cliff](https://git-cliff.org/) from conventional commit
messages. Configuration lives in `cliff.toml` at the project root.

### Generation

```bash
mise changelog:generate              # regenerate full changelog from all tags
mise changelog                       # preview unreleased changes (stdout)
git cliff --latest --output CHANGELOG.md # regenerate only the latest version
```

The generated format follows [Keep a Changelog](https://keepachangelog.com/):

```markdown
## [0.4.0] — 2026-02-15

### Added

- add unit placement and movement systems (unit)
- add unit type contract spec (contracts)

### Fixed

- prevent panel click from painting cells (editor_ui)

### Changed

- bump version to 0.4.0 (project)
```

### How commit messages map to changelog entries

| Commit type | Changelog group |
| ----------- | --------------- |
| `feat`      | Added           |
| `test`      | Added           |
| `docs`      | Added           |
| `fix`       | Fixed           |
| `refactor`  | Changed         |
| `style`     | Changed         |
| `chore`     | Changed         |

The commit scope becomes the parenthetical at the end of each entry.

### Manual edits

After generating, review the output. If a commit message was unclear or needs correction, edit
`CHANGELOG.md` directly. Prefer fixing the commit message convention going forward rather than
habitually hand-editing.

### Rules

- Never hand-write changelog entries from scratch — always generate first, then review
- The changelog is regenerated on every merge to `main` (Pre-Merge Checklist step 9)
- Versions are listed in reverse chronological order (newest first)

---

## Design Document Lifecycle

Design documents live in `docs/plans/` and are created during the orientation phase of a build
cycle. They capture implementation plans, architecture decisions, and design rationale.

### Lifecycle

| Phase                     | Status     | Source of Truth                                               |
| ------------------------- | ---------- | ------------------------------------------------------------- |
| **During implementation** | Active     | The design doc is the reference for approach and decisions    |
| **After implementation**  | Historical | The code, specs, contracts, and plugin logs are authoritative |

### After Implementation

When a pitch ships, the design doc becomes historical. Before marking it as such:

1. **Propagate key decisions** into permanent docs:
    - Architecture decisions → `docs/architecture.md` or plugin spec
    - Contract decisions → `docs/contracts/<name>.md`
    - Process learnings → plugin log or relevant guide
    - Deferred items → GitHub Issues
2. **Mark the design doc as historical** by adding a header at the top:
    ```markdown
    > **Historical** — Implemented in v0.x.0. The code, plugin specs, and contracts are now
    > authoritative. This document is preserved for context on why decisions were made.
    ```
3. Do not delete design docs — they serve as a record of _why_ decisions were made, which the
   permanent docs may not capture.

### Naming Convention

Design docs follow the pattern: `<date>-<feature-name>.md` or `<date>-<feature-name>-design.md` for
architecture-focused docs.

---

## Session Handoff Protocol

When a new Claude Code session picks up work on an existing feature branch, run these steps before
doing anything else.

**Quick start**: Run `mise handoff` to get a snapshot of worktrees, branch, status, commits, and
changed files. Then continue with the detailed steps below for anything that needs attention.

1. **Check for orphaned worktrees.** Run `git worktree list`. If there are worktrees from a prior
   session that is no longer active:
    - `cd` into the orphaned worktree and run `git status`.
    - If there are uncommitted changes, evaluate them: commit coherent work with a checkpoint commit
      (`chore(<feature>): recover uncommitted work from prior session`), or discard broken fragments
      with `git checkout -- .`.
    - If the worktree is for a different plugin than yours, leave it alone — another session may own
      it.
    - If the worktree is for your plugin, continue working in it. If you need a fresh worktree,
      clean up the orphan first: `git worktree remove <path>`.
2. **Identify the branch.** Run `git branch --show-current` to confirm you're on the correct feature
   branch.
3. **Check for uncommitted work.** Run `git status`. If there are unstaged or staged changes from a
   prior session, review them. Commit coherent work; discard broken fragments.
4. **Review branch history.** Run `git log --oneline main..HEAD` to see what the previous session(s)
   committed on this branch. Use the conventional commit format to reconstruct context:
    - **Group by type** to understand what was done: `feat` = new functionality, `fix` = bug fixes,
      `refactor` = restructuring, `test` = test additions, `docs` = spec/doc updates, `chore` =
      setup/config.
    - **Group by scope** to understand what was touched: each scope maps to a plugin module or
      `contracts`/`project`.
    - **Read commit bodies** (run `git log main..HEAD` without `--oneline`) for rationale and
      decisions — these serve as lightweight decision records between log entries.
    - **Identify the last checkpoint commit** (if any) — this marks the last known-good state the
      prior session saved before a risky change.
5. **Load context from diff.** Run `git diff main..HEAD --stat` for a file-level summary, then
   `git diff main..HEAD` for the full delta. This is the fastest way to understand what this branch
   has changed relative to mainline.
6. **Read the spec and log.** Open `docs/plugins/<name>/spec.md` and `docs/plugins/<name>/log.md`.
   The log records decisions, blockers, and test results from prior sessions.
7. **Check coordination.** Read `docs/coordination.md` for any contract changes or blockers that
   appeared since the last session.
8. **Resume the Development Workflow.** Pick up from the appropriate step in CLAUDE.md's Development
   Workflow based on what the prior session completed.

This protocol ensures no prior work is lost or duplicated, and the new session starts with full
context from git history + specs.

---

## Agent-Specific Rules

When a Claude Code session needs to commit:

1. **Read this guide first** — follow the message format and conventions
2. **Run the Pre-Commit Checklist** (above) for every commit
3. **Run the Pre-Merge Checklist** (above) for every merge to `main`
4. **Never force-push to `main`**
5. **Never commit secrets** (`.env`, credentials, API keys)
6. **Commit specs and code together** — a contract spec and its Rust implementation belong in the
   same commit
7. **Use the worktree for your plugin** — don't commit another plugin's work
8. **When in doubt, commit** — it's easier to squash later than to recover lost work
9. **Multi-terminal coordination**: each session works in its own worktree on its own branch
10. **Merge lock**: always claim the Merge Lock in `docs/coordination.md` before starting a merge to
    `main` — never merge without holding the lock
11. **Issue references**: reference GitHub Issue numbers in commits when closing or addressing
    tracked items (e.g., `fixes #42`, `ref #42`)
12. **Deferred items**: create GitHub Issues for deferred items before merge
13. **Duplicate check**: search existing issues before creating:
    `gh issue list --search "<keywords>" --state all`
